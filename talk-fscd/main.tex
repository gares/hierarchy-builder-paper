\documentclass[11pt]{beamer}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{sourcesanspro}
\usepackage{sourcecodepro}
\usepackage{euler}
\usepackage[normalem]{ulem}
\usepackage{natbib}
\usepackage{apalike}
\usepackage{minted} % pip3 install pygments, pdflatex -shell-escape hb
\newminted[elpicode]{../elpi.py:ElpiLexer -x}{linenos=false,fontsize=\footnotesize,frame=bottomline}

% \usepackage{bibentry}
% \usepackage{enumitem}
\usepackage[font={scriptsize},labelfont={scriptsize}]{caption}
\usepackage{lmodern,tgtermes,tabularx,ragged2e}
% \newcolumntype{Y}{>{\arraybackslash\RaggedRight}X}
% \newcolumntype{P}[1]{>{\arraybackslash\RaggedRight}p{#1}}
\usepackage{hhline}
\usepackage{booktabs}
\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\usepackage{makecell}
\usepackage{pdfpages}
% \usepackage[overlay,absolute]{textpos}
%   \setlength{\TPHorizModule}{1mm}
%   \setlength{\TPVertModule}{1mm}
\usepackage{graphicx}

% \nobibliography*
\setcitestyle{authoryear,comma,square,aysep={},yysep={}}
% \setbeameroption{hide notes}
% \setbeameroption{notes on second screen=right}
% \setbeameroption{use timer}
% \setbeameroption{use timer countdown=30}

\usetheme{inria}
%\usepackage{helvet}
\AtBeginSection[]{
  \begin{frame}[plain]
    \partpage
  \end{frame}
}
\newcommand{\inriaswitchcolors}[1]{%
\pgfaliasimage{figfootline}{figfootline-#1}% !!!
\pgfaliasimage{figbackground}{figbackground-#1}% !!!
\pgfaliasimage{figbackground}{figbackground-#1}% !!!
}
\setbeamertemplate{blocks}[rounded][shadow=true]
\setbeamercolor{block title}{fg=white,bg=inriaRed1}
\setbeamerfont{block title}{parent=frametitle,size=\small}
\setbeamerfont{section in toc}{parent=structure, size=\large}

% %remove the icon
% \setbeamertemplate{bibliography item}{}

% %remove line breaks
% \setbeamertemplate{bibliography entry title}{}
% \setbeamertemplate{bibliography entry location}{}
% \setbeamertemplate{bibliography entry note}{}

\usepackage{listings}
\usepackage{amsmath,amssymb}
% \usepackage{courier}

\usepackage{tikz}
\usepackage{tikz-cd}
\usetikzlibrary{decorations.pathreplacing,angles,quotes}
\usetikzlibrary{positioning}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{calc}
\usetikzlibrary{arrows,patterns}
\usetikzlibrary{intersections}
\usetikzlibrary{tikzmark,fit,shapes.geometric}

\definecolor{myviolet}{rgb}{0.6,0.0,0.65}
\definecolor{myblue}{rgb}{0.1,0.0,0.8}
\definecolor{mygreen}{rgb}{0.1,0.8,0.0}
\definecolor{myred}{rgb}{0.8,0.0,0.0}

\definecolor{dkblue}{rgb}{0,0.1,0.5}
\definecolor{lightblue}{rgb}{0,0.5,0.5}
\definecolor{dkgreen}{rgb}{0,0.4,0}
\definecolor{dk2green}{rgb}{0.4,0,0}
\definecolor{dkviolet}{rgb}{0.6,0,0.8}
\definecolor{shadethmcolor}{rgb}{0.9, 0.9,1}

\let\L=\lstinline
\def\lstlanguagefiles{defManSSR.tex}
\lstdefinelanguage{Prolog}
{
    basicstyle = \ttfamily\color{blue},
    moredelim = [s][\color{black}]{(}{)},
    literate =
        {:-}{{\textcolor{black}{:-}}}2
        {,}{{\textcolor{black}{,}}}1
        {.}{{\textcolor{black}{.}}}1
        {o:}{{\textcolor{black}{o:}}}1
        {i:}{{\textcolor{black}{o:}}}1
}

\lstset{language=SSR}
\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true}
\lstset{framextopmargin=50pt,frame=bottomline}
\lstset{moredelim=[is][\color{red}\bfseries\ttfamily\underbar]{|*}{*|}}
\lstset{moredelim=[is][\color{blue}\bfseries\ttfamily]{/*}{*/}}

\def\mathcomp{{\small\textsc{Mathematical Components}}}
\def\mydef#1{{\sl #1}}
\def\myem#1{{\bf\sl \color{red}{#1}}}
% \def\myem#1{\emph{#1}}

\newcommand{\cvg}[2]{#1 \rightarrow #2}
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\norm}[1]{\left\lVert #1 \right\rVert}
\newcommand{\scal}[2]{\left\langle #1, #2 \right\rangle}
\newcommand\IR{\ensuremath{\mathbb{R}}}
\newcommand\IC{\ensuremath{\mathbb{C}}}
\newcommand\nat{\ensuremath{\mathbb{N}}}
\newcommand\IN{\nat}

\renewcommand{\leq}{\leqslant}

\def\eps{\varepsilon}
\def\lip{LaSalle's invariance principle}
\def\o{\circ}
\def\coq{{\sc Coq}}
\def\ssr{{\sc SSReflect}}
\def\mathcomp{{\sc Mathematical Components}}
\def\coquelicot{{\sc Coquelicot}}
\def\isahol{{\sc Isabelle/HOL}}
\def\hol4{{\sc HOL4}}
\def\hollight{{\sc HOL Light}}
\def\lean{{\sc Lean}}
\def\pvs{{\sc PVS}}
\def\mizar{{\sc Mizar}}
\def\analysis{{\sc Mathematical Components Analysis}}
\def\plim{\Gamma^{+}}
\def\loc{\textrm{locally}}
\def\ball{\textrm{ball}}

\def\us{\char`\_}

\def\newterm#1{{\sl #1}} % to introduce new terms such as ``entourage'', etc.
\def\eg{\textit{e.g.}} % NB(rei): btw, the lncs authors' instructions uses the american convention (``e.g.,'' in roman)
\def\ie{\textit{i.e.}} % NB(rei): for uniformity (there was one with \em instead of \it)
\def\subset{\subseteq}
\def\supset{\supseteq}

% \makeatletter
% \renewenvironment{table}%
%   {\renewcommand\familydefault\sfdefault
%    \@float{table}}
%   {\end@float}
% \makeatother

\newcommand\doubleRule{\toprule\toprule}
\newcommand\doublerule{\toprule\specialrule{\heavyrulewidth}{\doublerulesep}{0.95em}}

\newcommand\coqPR[1]{\coq{} PR \href{https://github.com/coq/coq/issues/#1}{\##1}}
\newcommand\coqIssue[1]{\coq{} Issue \href{https://github.com/coq/coq/issues/#1}{\##1}}

\begin{document}

\title[Hierarchy Builder]{{Hierarchy Builder:}\\ {Algebraic
    hierarchies} \\ {made easy} {in {\sc Coq} with {\sc Elpi}}}
\subtitle{FSCD 2020}

\author[\underline{Cohen}, Sakaguchi, Tassi]{
  \underline{Cyril Cohen \textit{(Inria)}}, Kazuhiko Sakaguchi, Enrico
Tassi}

% \institute[]{\inst{1} Inria, France, \inst{2} University of Tsukuba,
% Japan}

\date{June 2nd, 2020}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}[fragile]
  \frametitle{Structures in Mathematics}

  Standard definition:
  \begin{itemize}
  \item A \textbf{carrier} in Set / Type,
  \item A set of \textbf{constants} in the carrier, and \textbf{operations},
  \item Proofs of the \textbf{axioms} of the structure
  \end{itemize}

  \pause
  \vfill

  E.g. an (additive) monoid is given by
  \begin{itemize}
  \item a carrier \L{T : Type},
  \item a constant \L{zero : T} and a binary operation %
    \L{add : T -> T -> T}
  \item three axioms: \\
    associativity of the addition, left and right neutrality of zero.
  \end{itemize}

\end{frame}


\begin{frame}[fragile]
  \frametitle{Implementations in DTT (unbundled classes) \\ \hfill [MSCS2011]}

\begin{lstlisting}
Class |*is_monoid*| T (zero : T) (add : T -> T -> T) := {
    addrA : associative add;
    add0r : left_id zero add;
    add0r : right_id zero add;
  }.
\end{lstlisting}

\end{frame}


\begin{frame}[fragile]
  \frametitle{Implementations in DTT (semi-bundled classes)}

\begin{lstlisting}
Class |*is_monoid*| (T : Type) : Type := {
    zero  : T;
    add   : T -> T -> T;
    addrA : associative add;
    add0r : left_id zero add;
    add0r : right_id zero add;
  }.
\end{lstlisting}

\vfill
  \begin{onlyenv}<2>
\begin{lstlisting}
Class |*is_group*| (T : Type) : Type :=
  { zero : T;  add : T -> T -> T; opp : T -> T; .. }.
\end{lstlisting}
  \end{onlyenv}
  \begin{onlyenv}<3>
\begin{lstlisting}
Class |*group_of_monoid*| T : |*is_monoid*| T -> Type :=
   { opp : T -> T; .. }.
\end{lstlisting}
  \end{onlyenv}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Implementations in DTT (bundled record)}

\begin{lstlisting}
Structure |*monoidType*| : Type := {
    sort  :> Type;
    zero  : sort;
    add   : sort -> sort -> sort;
    addrA : associative add;
    add0r : left_id zero add;
    add0r : right_id zero add;
  }.
\end{lstlisting}


\end{frame}
\begin{frame}[fragile]
  \frametitle{Implementations in DTT \\ \hfill (simplified packed classes)}

\begin{lstlisting}
Class |*is_monoid*| (T : Type) : Type := {
    zero  : T;
    add   : T -> T -> T;
    addrA : associative add;
    add0r : left_id zero add;
    add0r : right_id zero add;
  }.
\end{lstlisting}

\vfill

\begin{lstlisting}
Structure |*monoidType*| : Type := {
    sort  :> Type;
    class : |*is_monoid*| sort;
  }.
\end{lstlisting}


\end{frame}


\begin{frame}[fragile]
  \frametitle{Implementations in DTT (packed classes) \\ \hfill [TPHOL
    2009]}

\begin{lstlisting}
Record |*is_monoid*| (T : Type) : Type := { zero ; ..}.

Structure |*monoidType*| : Type :=
  { sort :> Type;     class : |*is_monoid*| sort }.
\end{lstlisting}


\begin{lstlisting}
Record |*group_of_monoid*| T : |*is_monoid*| T -> Type := ...

Record |*is_group*| (T : Type) := {
    monoid_of_group : |*is_monoid*| T;
    group_of_group  : |*group_of_monoid*| T monoid_of_group
  }.

Structure |*groupType*| : Type :=
  { sort :> Type;     class : |*is_group*| sort }.
\end{lstlisting}

\end{frame}

\begin{frame}
  \frametitle{Implementation in DTT (other)}

  Many other possibilities:
  \vfill
  \begin{itemize}
  \item Modules a la {\sc OCaml} \emph{(not first class in {\sc Coq}!)},
  \vfill
  \item Fully-bundled typeclasses \emph{(bad!)},
  \vfill
  \item Telescopes \emph{(bad!)},
  \vfill
  \item Records without inference \emph{(tedious!)},
  \vfill
  \item ...
  \end{itemize}

\end{frame}

\begin{frame}
  \frametitle{Implementations in proof assistants}

  The variety of representations is out there!

  % more details comming
  \begin{itemize}
  \item {\sc Coq/Mathcomp}:     Packed classes\only<3>{\alert{ inside canonical
    structures}}.
\item {\sc Coq/Math-Classes}: Fully unbundled \alt<3>{\alert{type classes}}{records} \\
    \hfill ($+$ special case for varieties).
  \item {\sc Lean3/Mathlib}:     Semi-bundled \alt<3>{\alert{type classes}}{records}.
  \item {\sc Agda}:             Bundled and semi-bundled records.
  \item ...
  \end{itemize}
  \vfill
  \pause

  \vfill
  \pause

\center{\textbf{Representations work hand in hand with tooling.}}

\end{frame}


\begin{frame}
  \frametitle{More than ``just records''}



  \begin{itemize}
  \item {\sc Coq/Mathcomp}:     canonicals \alert<1>{$+$ boilerplate
      $+$ validator [IJCAR]}
  \item {\sc Coq/Math-Classes}: type classes \alert<1>{$+$ boilerplate $+$ hints}
  \item {\sc Lean3/Mathlib}:     type classes \alert<1>{$+$ priorities $+$ linter}
  \item {\sc Agda}:             records \alert<1>{$+$ open and renaming directives}
  \end{itemize}

  \vfill
  \pause
  \vfill

  None of these encoding are straightforward:
  \begin{itemize}
  \item they all need expert knowledge and/or checkers/linters,
  \item some encodings are unnecessarily verbose,
  \item some known design problems might be detected too late
    (e.g. priority of instance, typeclass indexing, forgetful
    inheritance, etc)
  \end{itemize}

  % TODO: maybe insert here showing various encoding artifacts

  \vfill
  \pause
  \center{\textbf{Hierarchy Builder provides a DSL!}}
\end{frame}


\begin{frame}
  \frametitle{Hierarchies in formalization}

  Purpose:
  \begin{itemize}
  \item \textbf{factor theorems}, using the \emph{theory} of each structure,
  \item \textbf{automatically find} which structures hold on which types.
  \end{itemize}

  \pause
  \vfill

  Requirements:
  \begin{itemize}
  \item declare a \textbf{new instance},
  \pause
  \item declare a \textbf{new structure}
    \begin{itemize}
    \item above, below or in the middle
    \item handle diamonds (e.g. monoid, group, commutative or not),
    \item by amending existing code, or not,
    \end{itemize}
    \pause
  \item provide \textbf{several ways} to instantiate them
  \pause
  \item \textbf{predictability} of inferred instance,
  \pause
  \item \textbf{robustness} of user code with regard to \textit{new declarations}.
  \end{itemize}

\end{frame}

\begin{frame}
  \frametitle{Hierarchy Builder in two bullets}

  \begin{enumerate}
  \item \textbf{Hierarchy Builder provides a DSL to generate and extend a
      hierarchy from minimal input.}
    \vfill
  \item \textbf{Hierarchy Builder lets you amend a hierarchy without
      breaking your code.}
  \end{enumerate}

  \vfill

  Hierarchy Builder takes care of the design pattern used throughout
  your library.
\end{frame}


\begin{frame}
  \frametitle{Hierarchy Builder in practice}

  \begin{itemize}
  \item Hierarchy Builder generates/extends a hierarchy using \mathcomp{}
    packed class methodology.
    \vfill
  \item Hierarchy Builder enforces a discipline of \emph{mixins} and
    \emph{factories} to make client code robust to hierarchy changes.
    \vfill
  \item Hierarchy Builders lets us encode built-in safety measures
    (e.g. detection of overlapping instances)
  \end{itemize}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Structures relating to each other}

  Examples:

  \begin{itemize}
  \item Monoid $\leftarrow$ Group $\leftarrow$ Ring $\leftarrow$ Field
    $\leftarrow$ ...


  \item Normed Space $\rightarrow$ Metric Spaces $\rightarrow$
    Topological Spaces $\rightarrow$ ...

  \end{itemize}

  \pause
  \vfill{}

  \textbf{Going through arrows must be automated.}

  \pause
  \vfill{}

  Arrows represent both
  \begin{itemize}
  \item Extensions: add operations, axioms or combine structures
  \item Entailment/Induction/Deduction/Generalization.
  \end{itemize}

\end{frame}

\begin{frame}
  \frametitle{More examples \hfill [IJCAR]}

\begin{tikzpicture}[line width=1pt, structure/.style={draw, rounded corners=1mm, fill=white}, new/.style={preaction={fill, white}, pattern=crosshatch dots, pattern color=lightgray}, scale=0.7]
 \useasboundingbox (-6, -.5) rectangle (12, 10.5);
 % Replace `fill` with `pattern`s for the final version.
 %\draw[black!50, pattern=north east lines, pattern color=red!50, rounded corners=15mm] (-7.5, -.5) -- (-7.5, 7) -- (-4, 7) -- (2, 3) -- (2, -.5) -- cycle;
 %\draw[black!50, pattern=north west lines, pattern color=blue!50, rounded corners=15mm] (-8, -.5) -- (2, 4) -- (-4, 8) -- (0, 10) -- (10, 5) -- (10, -.5) -- cycle;
 %
 \node at (-1, 1) {\Large \begin{tabular}{c}''Calculus''\\structures\end{tabular}};
 \node at (6, 1) {\Large \begin{tabular}{c}''Algebraic''\\structures\end{tabular}};
 %
 \node[structure] (PartialOrder)          at (9,  9) {\L+PartialOrder+};
 \node[structure] (Lattice)         at (9,  7.67) {\L+Lattice+};
 \node[structure] (TotalOrder)           at (9,  6.33) {\L+TotalOrder+};
 %
 \node[structure] (AddGroup)             at (3,  9.5) {\L+AddGroup+};
 \node[structure] (Lmodule)              at (2, 7.3) {\L+Lmodule+};
 \node[structure] (Rings)                at (5,  8) {\L+(Com)(Unit)Ring+};
 \node[structure] (IntegralDomain)       at (5,  6.5) {\L+IntegralDomain+};
 \node[structure] (Field)                at (2,  5) {\L+Field+};
 \node[structure] (OrderedDomain)        at (8,  5) {\L+OrderedDomain+};
 \node[structure] (OrderedField)         at (5,  4) {\L+OrderedField+};
 \node[structure] (RealClosedField)      at (3,  3) {\L+RealClosedField+};
 \node[structure] (ArchimedeanField)     at (8,  3) {\L+ArchimedeanField+};
 %
 \node[structure] (TopologicalSpace)          at (-4, 9) {\L+TopologicalSpace+};
 \node[structure] (UniformSpace)              at (-4, 7.5) {\L+UniformSpace+};
 \node[structure] (Complete)             at (-5, 5) {\L+Complete+};
 \node[structure] (NormedAddGroup)       at (-2,  6.1) {\L+NormedAddGroup+};
 \node[structure] (NormedModule)         at (-1, 4.5) {\L+NormedModule+};
 \node[structure] (CompleteNormedModule) at (-3, 3) {\L+CompleteNormedModule+};
 %
 \draw[<-] (PartialOrder) to (Lattice);
 \draw[<-] (Lattice) to (TotalOrder);
 \draw[<-] (TopologicalSpace) to (UniformSpace);
 \draw[<-] (UniformSpace) to (Complete);
 \draw[<-] (UniformSpace) to (NormedAddGroup);
 \draw[<-] (Complete) to (CompleteNormedModule);
 \draw[<-] (Lmodule) to (NormedModule);
 \draw[<-] (NormedAddGroup) to (NormedModule);
 \draw[<-] (NormedModule) to (CompleteNormedModule);
 \draw[<-] (AddGroup) to (Lmodule);
 \draw[<-] (AddGroup) to (NormedAddGroup);
 \draw[<-] (AddGroup) to (Rings);
 \draw[<-] (Rings) to (IntegralDomain);
 \draw[<-] (IntegralDomain) to (OrderedDomain);
 \draw[<-] (NormedAddGroup) to (OrderedDomain);
 \draw[<-] (TotalOrder) to (OrderedDomain);
 \draw[<-] (IntegralDomain) to (Field);
 \draw[<-] (Field) to (OrderedField);
 \draw[<-] (OrderedDomain) to (OrderedField);
 \draw[<-] (OrderedField) to (RealClosedField);
 \draw[<-] (OrderedField) to (ArchimedeanField);

 % \draw[opacity=.5, black, fill=red!50, rounded corners=15mm] (-7.5, -.5) -- (-7.5, 7) -- (-4, 7) -- (2.5, 3) -- (2, -.5) -- cycle;
 % \draw[opacity=.5, black, fill=blue!50, rounded corners=15mm] (-8, -.5) -- (1.5, 4) -- (-4.3, 8) -- (0, 10) -- (10.5, 5.5) -- (10, -.5) -- cycle;
 \end{tikzpicture}

\end{frame}

\begin{frame}
  \frametitle{Structure extension vs Structure entailment}
  \begin{columns}
    \begin{column}{0.5\textwidth}
      \begin{center}
        {\bf \emph{Structure extension}}
      \end{center}
    \end{column}
    \begin{column}{0.5\textwidth}
      \begin{center}
        {\bf \emph{Structure entailment}}
      \end{center}
    \end{column}
  \end{columns}
  \vfill
  \begin{columns}
    \begin{column}{0.5\textwidth}
      \begin{itemize}
      \item \textbf{Compositional}: no need to start from scratch every time.
        (E.g. the product of two groups is a group)
        \pause\vfill
      \item \textbf{Noisy} internal definition of a structure.
        (E.g. defining a commutative monoid from a monoid, one gets an unnecessary axiom),
        \pause\vfill
      \item \textbf{Non-robust} when adding new
        intermediate structures, \pause\vfill
      \end{itemize}
    \end{column}
    \begin{column}{0.5\textwidth}
      \begin{itemize}
      \item \textbf{Flexible}: no need to cut structures
        into small bits,
        \pause\vfill
      \item \textbf{Robust}: we can fix operations and axioms
        once and for all.
        \pause\vfill
      \item \textbf{Not suitable for inference}: Major breakage when
        arbitrary entailment is automatic. (cf IJCAR \emph{Competing
          Inheritance Paths in Dependent Type Theory)} \pause\vfill
      \end{itemize}
    \end{column}
  \end{columns}
  \vfill

\end{frame}


\begin{frame}
  \frametitle{HB Design}

  The best of two the worlds:
  \begin{itemize}
  \item \textbf{Extension}, through \emph{mixins} for \textbf{automatic inference}

  \item \textbf{Entailment}, through \emph{factories} for
    \textbf{smart instantiation}

    % Factories require mixins and can produces others.
    % (e.g. a full axiomatic can provide all the pieces)
  \end{itemize}
  \vspace{2em}
  \pause
  \vfill

  Five primitives:
  \begin{enumerate}
  \item \L{HB.mixin     Record |*<mixin name>*|$ $ T of |*<dependencies>*| := \{..\}.}
    \vspace{1em}
  \item \L{HB.factory   Record |*<factory name>*|$ $ T of |*<dependencies>*| := \{..\}.}
  \item \L{HB.builders   Context       T (f : |*<factory name>*|$ $ T). ... HB.end.}
    \vspace{1em}
  \item \L{HB.structure Definition    |*<structure name>*|$ $ :=} \L{\{ T & |*<dependencies>*| \}}
  \item \L{HB.instance  Definition    |*<name>*|$ $ : |*<axioms name>*| |*<type>*| := ...}
  \end{enumerate}
  \vfill

  \pause
  \begin{center}
    see \url{https://github.com/math-comp/hierarchy-builder}
  \end{center}

\end{frame}

\begin{frame}[fragile]
  \frametitle{A very short example}
{\scriptsize\url{https://github.com/math-comp/hierarchy-builder/tree/master/FSCD2020_talk}}

\begin{lstlisting}
HB.mixin Record |*is_monoid*| (M : Type) := {
  zero  : M;
  add   : M -> M -> M;
  addrA : associative add;   (* add is associative. *)
  add0r : left_id  zero add; (* zero is the neutral *)
  addr0 : right_id zero add; (*    element wrt add. *)
}.
HB.structure Definition |*Monoid*| := { M & |*is_monoid*| M }.

HB.instance Definition Z_is_monoid : |*is_monoid*| Z
  := |*is_monoid*|.Build Z 0%Z Z.add
    Z.add_assoc Z.add_0_l Z.add_0_r.
\end{lstlisting}
  \vfill

  A bigger demo at the Coq Workshop, Monday 10AM GMT+2.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Breaking down monoid}

  We split the monoid structure into a semi-group and a monoid
\begin{lstlisting}
HB.mixin Record |*is_semigroup*| (S : Type) := {
  add   : S -> S -> S;
  addrA : associative add;
}.
HB.structure Definition |*SemiGroup*| :=
  { S & |*is_semigroup*| S }.
\end{lstlisting}
\begin{lstlisting}
HB.mixin Record |*monoid_of_semigroup*| (M : Type)
  & |*is_semigroup*| M := {
  zero  : M;
  add0r : left_id  zero add;
  addr0 : right_id zero add;
}.
HB.structure Definition |*Monoid*| :=
  { M & |*monoid_of_semigroup*| M }.
\end{lstlisting}
  \begin{center}
    \textbf{But we must provide \L{|*is_monoid*|} again.}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recovering the lost mixin (\L{is_monoid})}

  It becomes a \emph{factory} with the \textbf{exact} same contents as before
\begin{lstlisting}
HB.factory Record |*is_monoid*| (M : Type) := {
  zero  : M;
  add   : M -> M -> M;
  addrA : associative add;
  add0r : left_id  zero add;
  addr0 : right_id zero add;
}.
HB.builders Context (M : Type) (f : |*is_monoid*| M).
  HB.instance Definition is_monoid_semigroup
    : |*is_semigroup*| M := ... (* trivial *)
  HB.instance Definition is_monoid_monoid
    : |*monoid_of_semigroup*| M := ... (* trivial *)
HB.end
\end{lstlisting}
  \begin{center}
    \textbf{Factories can only be used at instantiation time:}
  \end{center}
\begin{lstlisting}
HB.instance Definition Z_is_monoid : |*is_monoid*| Z := ...
\end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{Meta programming in {\sc Coq-ELPI}}

  \textbf{{\sc Elpi} is a programming language,} \hfill [LPAR-20]
  \begin{itemize}
  \item prolog-like: \textbf{programs and data are clauses}
  \item with binders, unification and constraints
    \pause
  \item capable if representing {\sc Coq} terms in HOAS, its typing
    judgements, evaluation and unification.
  \end{itemize}
    \pause
    \vfill

  \textbf{{\sc Coq-Elpi} is a plugin for {\sc Coq}} that lets one use {\sc Elpi} as a
    meta-programming language, \pause in particular
  \begin{itemize}
  \item one can write new commands and tactics,
  \item one can add new definitions, inductive, sections, modules, etc
    to the environment,
  \item one can maintain databases across {\sc Coq} files
  \end{itemize}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Two main HB databases}

  \begin{itemize}
  \item The predicate \L{from} stores an association between a factory
    \L{F}, a mixin \L{M} and the term \L{B} that can be used to build
    mixin \L{M} from factory \L{F}.
\begin{elpicode}
pred from o:factoryname, o:mixinname, o:term.
\end{elpicode}
\vfill
  \item The predicate {\footnotesize\tt factory-requires} stores an
    association between a factory and a list of mixins that are
    pre-requisites to inhabiting this factory.
\begin{elpicode}
pred factory-requires o:factoryname, o:list mixinname.
\end{elpicode}
    e.g. \L{group_of_monoid T} has the prerequisite that \L{T} is a
    monoid.
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Conclusion}

  \begin{itemize}
  \item High-level commands to declare structures and instances, \\
    easy to use.
    \vfill
  \item Predictable outcome of inference,
    \vfill
  \item Takes into account the evolution of knowledge
    \begin{itemize}
    \item which is formalized, and
    \item which the user has.
    \end{itemize}
    The two knowledge do not need to be correlated.
    \vfill
  \item Robustness with regard to new declaration \emph{and even changes of
    internal implementation}.
  \end{itemize}

  \vfill\pause
  Also, \textsc{Coq-ELPI} turned out to be a very comfortable
  meta-programming language for this (approx. 2000 loc).

\end{frame}

\begin{frame}
  \frametitle{Future work on Hierarchy Builder}
  \begin{itemize}
  \item Adding support for parameters. (debugging phase in progress)
    \vfill
  \item Replacing all uses in math-comp and extensions. (just started)
    \vfill
  \item Get better error messages. (work in progress)
    \vfill
  \item Detecting and fixing competing inheritance paths.
    \vfill
  \item Generating hierarchies of morphisms from structures.
    \vfill
  \item Generating hierarchies of subobjects from structures.
    \vfill
  \item Supporting multiple instances on the same carrier.
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{center}
   {\huge Thanks! Questions?}
  \end{center}
\end{frame}

\end{document}
