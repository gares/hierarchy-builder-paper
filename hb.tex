
\documentclass[a4paper,UKenglish,cleveref, autoref]{lipics-v2019}
\usepackage{hyperref}
\usepackage{minted} % pip3 install pygments, pdflatex -shell-escape hb
\newminted[elpicode]{elpi.py:ElpiLexer -x}{linenos=true,fontsize=\footnotesize,escapeinside=\%\%}
\newmintinline[elpi]{elpi.py:ElpiLexer -x}{fontsize=\small}
\newminted[coqcode]{elpi.py:CoqElpiLexer -x}{linenos=true,fontsize=\footnotesize,mathescape,escapeinside=\#\#}
\newmintinline[coq]{elpi.py:CoqElpiLexer -x}{fontsize=\small}
\usepackage{xcolor}
\usepackage{wrapfig}

\definecolor{dkgreen}{rgb}{0, 0, 1}

\newcommand{\coqelpi}{Coq-Elpi}
\newcommand{\HB}{\ensuremath{\mathcal{HB}}}
\newcommand{\hb}{\coq{hierarchy-builder}}

%This is a template for producing LIPIcs articles.
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling cleveref support, use "autoref"


%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Hierarchy Builder: algebraic~hierarchies made easy in Coq with Elpi} %TODO Please add

\titlerunning{Hierarchy Builder}%optional, please use if title is longer than one line
\author{Cyril Cohen}{Inria, Universit\'e C\^ote d'Azur, France}{Cyril.Cohen@inria.fr}{}{}
\author{Kazuhiko Sakaguchi}{University of Tsukuba, Japan}{sakaguchi@logic.cs.tsukuba.ac.jp}{}{}
\author{Enrico Tassi}{Inria, Universit\'e C\^ote d'Azur, France}{Enrico.Tassi@inria.fr}{}{}
\authorrunning{C.\,Cohen and K.\,Sakaguchi and E.\,Tassi}
% \author{John Q. Public}{Dummy University Computing Laboratory, [optional: Address], Country \and My second affiliation, Country \and \url{http://www.myhomepage.edu} }{johnqpublic@dummyuni.org}{https://orcid.org/0000-0002-1825-0097}{(Optional) author-specific funding acknowledgements}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional
% \author{Joan R. Public\footnote{Optional footnote, e.g. to mark corresponding author}}{Department of Informatics, Dummy College, [optional: Address], Country}{joanrpublic@dummycollege.org}{[orcid]}{[funding]}
% \authorrunning{J.\,Q. Public and J.\,R. Public}%TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Cyril Cohen and Kazuhiko Sakaguchi and Enrico Tassi}%TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc{Software and its engineering~Formal language definitions}
\ccsdesc{Theory of computation~Type theory}
\ccsdesc{Theory of computation~Constraint and logic programming}
\ccsdesc{Computing methodologies~Symbolic and algebraic manipulation}

\supplement{Coq package source: \url{https://github.com/math-comp/hierarchy-builder}}
\keywords{Algebraic Hierarchy, Packed Classes, Coq, Elpi, Metaprogramming, $\lambda$Prolog}%TODO mandatory; please add comma-separated list of keywords

\category{System Description}%optional, e.g. invited paper

%\relatedversion{System Description}%optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversion{A full version of the paper is available at \url{...}.}

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

%\acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering

%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{Zena M. Ariola}
\EventNoEds{1}
\EventLongTitle{5th International Conference on Formal Structures for Computation and Deduction (FSCD 2020)}
\EventShortTitle{FSCD 2020}
\EventAcronym{FSCD}
\EventYear{2020}
\EventDate{June 29--July 5, 2020}
\EventLocation{Paris, France}
\EventLogo{}
\SeriesVolume{167}
\ArticleNo{8}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO: Write glossary
% remove distinction
% TODO: Structure -> Class
% TODO: packager -> ClassBuilder
% TODO: Builder -> Builder
% Factories ( primitive / general ) ; kill mixin

\newcommand{\Lang}{\ensuremath{\Lambda}}
\newcommand{\term}{term}
\newcommand{\mixin}{mixin}
\newcommand{\mixins}{mixins}
\newcommand{\Mixins}{Mixins}
\newcommand{\M}{\ensuremath{\mathcal{M}}}
\newcommand{\factory}{factory}
\newcommand{\factories}{factories}
\newcommand{\Factories}{Factories}
% \newcommand{\packager}{packager}
% \newcommand{\packagers}{packagers}
% \newcommand{\Packager}{Packager}
\newcommand{\phantterm}{abbreviation}
\newcommand{\phantterms}{abbreviations}
\newcommand{\Phantterms}{abbreviations}
\newcommand{\builder}{builder}
\newcommand{\mixinbuilder}{builder}
\newcommand{\mixinbuilders}{builders}
\newcommand{\factoryinstance}{factory instance}
\newcommand{\factoryinstances}{factory instances}
\newcommand{\F}{\ensuremath{\mathcal{F}}}
\newcommand{\dep}{\ensuremath{\mathit{dep}}}
\newcommand{\powerset}[1]{\raisebox{.15\baselineskip}{\Large\ensuremath{\wp}}(#1)}
\newcommand{\C}{\ensuremath{\mathcal{C}}}
\newcommand{\B}{\ensuremath{\mathcal{B}}}
\newcommand{\class}{class}
\newcommand{\classes}{classes}
\newcommand{\cdef}{\ensuremath{\mathit{def}}}
\newcommand{\Str}{\ensuremath{\mathcal{S}}}
\newcommand{\structure}{structure}
\newcommand{\structures}{structures}
\newcommand{\issubclass}{\ensuremath{\leq}}
\newcommand{\subclass}{subclass}
\newcommand{\join}{\ensuremath{\mathit{join}}}
\newcommand{\requires}{\ensuremath{\mathit{requires}}}
\newcommand{\target}{\ensuremath{\mathit{target}}}
\newcommand{\provides}{\ensuremath{\mathit{provides}}}
\newcommand{\from}{\ensuremath{\mathsf{from}}}
\newcommand{\proj}[2]{\ensuremath{#1[#2]}}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\enum}[2]{\ensuremath{\set{#1,\ldots,#2}}}
\newcommand{\vect}[1]{\overrightarrow{#1}}
\newcommand{\pmp}[1]{\ensuremath{\vect{\left(p : m\ T\ p_\sigma\right)}^{#1}}}
\newcommand{\aux}{\mathit{aux}}
\newcommand{\hbmixin}{{\tt\color{dkgreen}HB.mixin}}
\newcommand{\hbfactory}{{\tt\color{dkgreen}HB.factory}}
\newcommand{\hbinstance}{{\tt\color{dkgreen}HB.instance}}
\newcommand{\hbstructure}{{\tt\color{dkgreen}HB.structure}}
\newcommand{\hbbuilders}{{\tt\color{dkgreen}HB.builders}}
\newcommand{\hbend}{{\tt\color{dkgreen}HB.end}}

\newtheoremstyle{implem}{\topsep}{\topsep}{}{0pt}{\sffamily\bfseries}{ }{5pt plus 1pt minus 1pt}%
{$\blacktriangleright$ \thmname{#1}\thmnumber{ #2}\thmnote{ #3}}

\theoremstyle{implem}
\newtheorem*{implementation}{Implementation of}

\theoremstyle{implem}
\newtheorem*{invariant}{Programming invariant for}

\newtheoremstyle{command}{\topsep}{\topsep}{}{0pt}{\sffamily\bfseries}{ }{5pt plus 1pt minus 1pt}%
{$\blacktriangleright$ \thmname{#1} {\coq{#3}}}
\theoremstyle{command}
\newtheorem*{command}{Coq command}

\newtheoremstyle{commands}{\topsep}{\topsep}{}{0pt}{\sffamily\bfseries}{ }{5pt plus 1pt minus 1pt}%
{$\blacktriangleright$ \thmname{#1} {\coq{#3}}}
\theoremstyle{commands}
\newtheorem*{commands}{Coq commands}

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
It is nowadays customary to organize libraries of machine checked
proofs around hierarchies of algebraic
structures~\cite{DBLP:conf/mpc/AffeldtNS19,DBLP:journals/mics/BoldoLM15,Cohen_phd,Holzl:2013,10.1145/3372885.3373824,Rouhling_phd,mathclasses}.
One influential example is the Mathematical Components library on top
of which the long and intricate proof of the Odd Order
Theorem could be fully formalized~\cite{DBLP:conf/itp/GonthierAABCGRMOBPRSTT13}.

Still, building algebraic hierarchies in a proof assistant such as Coq~\cite{Coq:manual}
requires a lot of manual labor and often a deep expertise in the internals of
the prover~\cite{DBLP:conf/tphol/GarillotGMR09,DBLP:conf/itp/MahboubiT13}.
Moreover, according to our experience~\cite{KSdraft},
making a hierarchy evolve without causing breakage in client code is equally tricky:
even a simple refactoring such as splitting a structure into two simpler ones
is hard to get right.

In this paper we describe \HB{}, a high level language
to \emph{build} hierarchies of algebraic structures and to make these hierarchies
\emph{evolve} without breaking user code. The key concepts are the ones of
\emph{\factory{}}, \emph{\mixinbuilder{}} and \emph{\phantterm{}} that let the hierarchy developer
describe an actual
interface for their library. Behind that interface the developer can provide
appropriate code to ensure backward compatibility.
We implement the \HB{} language in the \hb{} addon for the Coq
system using the Elpi~\cite{DBLP:conf/lpar/DunchevGCT15,CoqElpi}
extension language.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

Modern libraries of machine checked proofs are organized around
hierarchies of algebraic structures~\cite{DBLP:conf/mpc/AffeldtNS19,DBLP:journals/mics/BoldoLM15,Cohen_phd,Holzl:2013,10.1145/3372885.3373824,Rouhling_phd,mathclasses}.
For example the Mathematical Components library for the Coq system~\cite{Coq:manual}
provides a very rich, ever growing, hierarchy of structures such as
group, ring, module, algebra, field, partial order, order, lattice\ldots
The hierarchy does not only serve the purpose of organizing knowledge, but
also to make it easy to exploit it. Indeed the interactive prover can
take advantage of the structure of the library and the relation between
its concepts to infer part of information usually left implicit
by the user, a capability that turned out to be key to tame
the complexity and size of the formal proof of the Odd Order
Theorem~\cite{DBLP:conf/itp/GonthierAABCGRMOBPRSTT13}.

The hierarchy of the Mathematical Components library
is implemented following the discipline of Packed Classes initially introduced
by Garillot, Gonthier, Mahboubi and Rideau~\cite{DBLP:conf/tphol/GarillotGMR09}
and later also adopted by Affeldt, Nowak, and Saikawain
to describe a hierarchy of monadic effects~\cite{DBLP:conf/mpc/AffeldtNS19}
and by Boldo, Lelay, and Melquiond in the Coquelicot library of real
analysis~\cite{DBLP:journals/mics/BoldoLM15}.
We call Packed Classes a discipline, and not a language, because, in spite of
its many virtues, it is unwieldy to use. In particular it leaks to the user
many of the technical details of the Coq system. As a result, one
needs to be a Coq expert in order to build or modify a hierarchy, and even
experts make mistakes as shown in~\cite{KSdraft}.
Another inconvenience of the Packed Classes discipline is that even
simple changes to the hierarchy, such as splitting a structure into
two simpler ones, break user code.

In this paper we describe \HB{}, a high level language
to \emph{build} hierarchies of algebraic structures and to make these hierarchies
\emph{evolve} without breaking user code. The key concepts are the ones of
\emph{\factory{}}, \emph{\builder{}} and \emph{\phantterm{}} that let the hierarchy developer describe an actual
interface for their library. Behind that interface the developer can provide
appropriate code to ensure backward compatibility.
We implement the \HB{} language by compiling it
to a variant of the Packed Classes discipline, that we call \emph{flat},
in the \hb{} addon for Coq. We write this addon using the
Elpi~\cite{DBLP:conf/lpar/DunchevGCT15,CoqElpi} extension language.\\

\noindent To sum up, the main contributions of the paper are:
\begin{itemize}
\item the design of the \HB{} language,
\item the compilation of \HB{} to the (flat) Packed Classes discipline, and
\item the implementation of \HB{} in the \hb{} addon for Coq.
\end{itemize}
The paper is organized as follows. Via an example we introduce
\HB{} and its key ideas. %We then provide a formal description of \HB{}.
We then describe the discipline
of Packed Classes and we show how \HB{} can be compiled to it.
We then discuss the implementation of the Coq addon via the Elpi extension
language and we position \HB{} in the literature.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
\section{\HB{} by examples: building and evolving a hierarchy}
\label{sec:example}

The first version of our hierarchy (that we name V1) features only two
structures: \coq{Monoid} and \coq{Ring}. We use notations from Appendix~\ref{sec:coq-reference} to define them.
%\marginpar{remove hb.end for \mixins{}, use next release of coq elpi}
\begin{coqcode}
#\hbmixin{}# Record Monoid_of_Type M := {                       #\label{demo:mixin:mot}#
  zero : M;
  add : M -> M -> M;
  addrA : associative add;             (* `add` is associative.                   *)
  add0r : left_id zero add;            (* `zero` is the left and right neutral    *)
  addr0 : right_id zero add;           (*   element with respect to `add`.        *)
}.                                                             #\label{demo:mixin:mot:end}#
#\hbstructure{}# Definition Monoid := { M of Monoid_of_Type M }.        #\label{demo:structure:monoid}#

#\hbmixin{}# Record Ring_of_Monoid R of Monoid R := {       #\label{demo:mixin:rom}#
  one : R;
  opp : R -> R;
  mul : R -> R -> R;
  addNr : left_inverse zero opp add;   (* `opp x` is the left and right additive  *)
  addrN : right_inverse zero opp add;  (*   inverse of `x`.                       *)
  mulrA : associative mul;             (* `mul` is associative.                   *)
  mul1r : left_id one mul;             (* `one` is the left and right neutral     *)
  mulr1 : right_id one mul;            (*   element with respect to `mul`.        *)
  mulrDl : left_distributive mul add;  (* `mul` is left and right distributive    *)
  mulrDr : right_distributive mul add; (*   over `add`.                           *)
}.
#\hbstructure{}# Definition Ring := { R of Monoid R & Ring_of_Monoid R }. #\label{demo:structure:ring}#

\end{coqcode}

In order to build a structure we need to declare some \factories{} and
later assemble them. One kind of \factory{} supported by \HB{}, the simplest
one, is called \emph{\mixin{}} and is embodied by a record
that gathers operations and properties.

\Mixins{} are declared via the \hbmixin{} command
that takes a record declaration with
a type parameter and a possibly empty list of \factories{} for that type.
The code between lines~\ref{demo:mixin:mot}
and~\ref{demo:mixin:mot:end} declares a \mixin{} that can turn a naked
type \coq{M} into a monoid, hence we chose the name to be \coq{Monoid_of_Type}.

The \hbstructure{} command takes in input a definition for a sigma type \coq{S}
that equips a type with a list of \factories{}.
It registers a structure \coq{S} in the hierarchy placing
any definition specific to that structure inside a Coq module named \coq{S}.
Line~\ref{demo:structure:monoid} hence forges the \coq{Monoid} structure.

Line~\ref{demo:mixin:rom} declares a second \mixin{} collecting the operations
and properties that are needed in order to enrich a monoid to a ring, hence
the name \coq{Ring_of_Monoid}. Indeed this time the type variable \coq{R}
is followed by \coq{Monoid} that enriches
\coq{R} with the operations and properties of monoids. As a consequence
\coq{add} and \coq{zero} can be used to express the new properties.

The last line declares the \coq{Ring} structure to hold all the axioms declared
so far. We can now inspect the contents of the hierarchy and then
proceed to build a theory about abstract rings,
register examples (instances) of ring structures
and finally use the abstract theory on these examples.

\begin{coqcode}
Print Monoid.type. (* Monoid.type  :=  { sort : Type;  ... }                           *) #\label{demo:theory:print:type}#
Check @add.        (* add          :   forall M : Monoid.type, M -> M -> M             *) #\label{demo:theory:check:add}#
Check @addNr.      (* addNr        :   forall R : Ring.type, left_inverse zero opp add *) #\label{demo:theory:check:addNr}#

Lemma addrC {R : Ring.type} : commutative (@add R).                       #\label{demo:theory:state:addrC}#
Proof. (* Proof by Hankel 1867, in Appendix B *) Qed.

Definition Z_Monoid_axioms : Monoid_of_Type Z :=                         #\label{demo:theory:z:monoid:axioms}#
  Monoid_of_Type.Build Z 0%Z Z.add Z.add_assoc Z.add_0_l Z.add_0_r.

#\hbinstance{}# Z Z_Monoid_axioms.                                            #\label{demo:theory:z:monoid:canonical}#

Definition Z_Ring_axioms : Ring_of_Monoid Z :=                        #\label{demo:theory:z:ring:axioms}#
  Ring_of_Monoid.Build Z 1%Z Z.opp Z.mul
    Z.add_opp_diag_l Z.add_opp_diag_r Z.mul_assoc Z.mul_1_l Z.mul_1_r
    Z.mul_add_distr_r Z.mul_add_distr_l.

#\hbinstance{}# Z Z_Ring_axioms.                                              #\label{demo:theory:z:ring:canonical}#

Lemma exercise (m n : Z) : (n + m) - n * 1 = m.
Proof. by rewrite mulr1 (addrC n) -(addrA m) addrN addr0. Qed.
\end{coqcode}

We can print the type for monoids as forged by \HB{} (line~\ref{demo:theory:print:type}).
It packs a carrier, called \coq{sort}, and the collection of operation and
properties that we omit for brevity.  We can also look at the type of two
constants synthesized by \HB{} out of the hierarchy declaration. Remark that
while the names of the constants come from the names of \mixin{} fields,
their types differ.
In particular they are quantified over a \coq{Monoid.type} or \coq{Ring.type},
and not a simple type as in the \mixins{}. Moreover we evince that
the \coq{sort} projection is declared as an implicit coercion~\cite{Saibi97}
and is automatically inserted in order to make \coq{M -> M -> M} a meaningful
type for binary operations on the carrier of \coq{M}. Last, we see that
properties are quantified on (hence apply to) the structure they belong to but
use, in their statements, operations belonging to simpler structures.
For example \coq{addNr} is a property of a ring but  its statement mentions \coq{add},\
the operation of the underlying monoid.

We then follow the proof of Hankel~\cite{nearrings} to show that
ring axioms imply the commutativity of the underlying monoid
(line~\ref{demo:theory:state:addrC}). This simple example shows we can
populate the theory of abstract rings with new results.

We use the \coq{Monoid_of_Type.Build} \emph{\phantterm{}}
(line~\ref{demo:theory:z:monoid:axioms})
in order to build an instance of the \coq{Monoid}
structure for binary integers \coq{Z}.
We then register that monoid instance as the canonical one on \coq{Z}
(line~\ref{demo:theory:z:monoid:canonical}) via the command
\coq{HB.instance}.
We can similarly declare that \coq{Z} forms a ring by using
the \coq{Ring_of_Monoid.Build} \phantterm{}
(lines~\ref{demo:theory:z:ring:axioms} and~\ref{demo:theory:z:ring:canonical}).
Note that the \coq{Ring_of_Monoid.Build} \phantterm{} is not
a plain record constructor for \coq{Ring_of_Monoid}, since that
would require more arguments, namely the monoid ones (see the \coq{_}
at line~\ref{demo:theory:z:ring:axioms}). The
\phantterm{} synthesized by \HB{} infers them automatically
(as in~\cite[Section 7]{DBLP:conf/itp/MahboubiT13}) thanks to the \hbinstance{}
declaration given just above.

From now on the axioms as well as the abstract theory of rings apply to
integers, as shown in lemma \coq{exercise}. The details of the proof
do not matter here, what is worth pointing out is that in a single
statement we mix monoid (e.g.~\coq{+}) and ring (e.g.~\coq{-}) operations and in the
proof we use monoid axioms (e.g.~\coq{addrA}), ring axioms
(e.g.~\coq{addrN}) and ring lemmas (e.g.~\coq{addrC}), all seamlessly.

\subsection{Evolution of the hierarchy}\label{subsec:evolution}

We proceed by accommodating the intermediate
structure of Abelian groups.

\begin{coqcode}
#\hbmixin{}# Record Monoid_of_Type M := { ... (* unchanged *) ... }.
#\hbstructure{}# Definition Monoid := { M of Monoid_of_Type M }.

#\hbmixin{}# Record AbelianGroup_of_Monoid A of Monoid A := {
  opp : A -> A;
  addrC : commutative (add : A -> A -> A);
  addNr : left_inverse zero opp add;
}.
#\hbstructure{}# Definition AbelianGroup := { A of Monoid A & AbelianGroup_of_Monoid A }.

#\hbmixin{}# Record Ring_of_AbelianGroup R of AbelianGroup R := {
  one : R;
  mul : R -> R -> R;
  mulrA : associative mul;
  mul1r : left_id one mul;              mulr1 : right_id one mul;
  mulrDl : left_distributive mul add;   mulrDr : right_distributive mul add;
}.
#\hbstructure{}# Definition Ring := { R of AbelianGroup R & Ring_of_AbelianGroup R }.

Lemma addrN {A : AbelianGroup.type} : right_inverse zero opp add.               #\label{demo2:proof:addrN}#
Proof. by move=> x; rewrite addrC addNr. Qed.
\end{coqcode}

Some operations and properties were moved from the old \mixin{} for rings
into a newborn \mixin{} \coq{AbelianGroup_of_Monoid} that gathers the
axioms needed to turn a monoid into an Abelian group. Consequently the \mixin{}
for rings is now called \coq{Ring_of_AbelianGroup} (instead of \coq{Ring_of_Monoid})
since it expects the type \coq{R} to be already an Abelian group and hence
gathers fewer axioms.
While operations moved from one structure to another, some properties
undergo a deep change in their status.
The lemma \coq{addrC} part of the abstract theory of
rings is now an axiom of Abelian groups, while \coq{addrN} is no more
an axiom of rings, but rather a theorem of the abstract theory of Abelian
groups proved at line~\ref{demo2:proof:addrN}.

It is worth clarifying here what axioms and lemmas are by looking at the
two distinct use cases for a hierarchy: 1) develop the abstract theory of some
structure; 2) apply the abstract theory on some concrete example.
In the first case
all the axioms of the structure are (assumed to be) theorems so the distinction
between axiom and theorem does not matter. This is what happens
in the proof of \coq{addNr} by taking \coq{R} to be of type
\coq{AbelianGroup.type} as an assumption.
In the second case,
in order to show Coq that a data type and some operations forms a structure,
one must pick the axioms of the structure an prove them for that specific
type and operations. For example the \coq{Ring_of_Monoid.Build} \phantterm{}
is used at page~\pageref{demo:theory:z:ring:axioms} to package the set
of proofs that make \coq{Z} a ring (proviso \coq{Z} is already a monoid).

With this new version of the hierarchy, that we name V2, the axiomatic that
was previously exposed to user changed, and indeed
code written for version V1 breaks. For example the declaration of the
canonical ring over the integers fails, if only
because we do not have a \coq{Ring_of_Monoid.Build} \phantterm{}
anymore.

Our objective is to obtain a version of the hierarchy, that we name V3, that does
not only feature Abelian groups but that is also backward compatible
with V1.

\subsection{The missing puzzle piece}\label{subsec:v3}

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=\textwidth]{puzzle.pdf}
  \end{center}
  \caption{\label{fig:puzzle}The evolution of the hierarchy. V3 is backward compatible with V1, while V2 is not.}
\end{figure}

The key to make a hierarchy evolve without breaking user code is the full
fledged notion of \emph{\factory{}} (the \mixins{} seen so far are degenerate,
trivial, \factories{}).
\Factories{}, like \mixins{}, are packages for operations and properties but are
not directly used in the definition of structures. Instead a \factory{} is
equipped with \emph{\builder{}s}: user provided pieces of code that extract
from the \factory{} the contents of \mixins{}, so that existing
\phantterm{}s can be used.

As depicted in Figure~\ref{fig:puzzle} we change again the hierarchy
by declaring a \coq{Ring_of_Monoid} \factory{}, that, from the user point of view,
will look indistinguishable from the old \coq{Ring_of_Monoid} \mixin{}
and hence grant backward compatibility between version V3 and version V1.

\begin{coqcode}
#\hbfactory{}# Record Ring_of_Monoid R of Monoid R := { ... (* unchanged *) ...}.

#\hbbuilders{}# Context R (f : Ring_of_Monoid R).                          #\label{demo3:variable:f}#

  Lemma addrC : commutative add. Proof. (* The same proof as before *) Qed.

  Definition to_AbelianGroup_of_Monoid :=
    AbelianGroup_of_Monoid.Build R opp addrC addNr. (* addrN unused *)
  #\hbinstance{}# R to_AbelianGroup_of_Monoid.

  Definition to_Ring_of_AbelianGroup := Ring_of_AbelianGroup.Build R one mul
    mulrA mul1r mulr1 mulrDl mulrDr.
  #\hbinstance{}# R to_Ring_of_AbelianGroup.

#\hbend{}#.
\end{coqcode}

The record \coq{Ring_of_Monoid} is the same we declared as a \mixin{}
in version V1. In order to make a \factory{} out of it we equip it with
two definitions that embody the \emph{\builder{}s}.
The first is \coq{to_AbelianGroup_of_Monoid} and
explains how to build an \coq{AbelianGroup} structure out of the \factory{}
axioms (named \coq{f}, line~\ref{demo3:variable:f}).
This construction is also registered as canonical for \coq{R},
so that the next construction \coq{to_Ring_of_AbelianGroup} can call
the \coq{Ring_of_AbelianGroup.Build} \phantterm{} that requires \coq{R} to be
an \coq{AbelianGroup}.
It is worth pointing out that the proof of \coq{addrC} we had in V1 is now
required in order to write the \builder{} for Abelian groups, while
the \coq{addrN} field is not used (the same statement is already part of
the theory of Abelian groups, see line~\ref{demo2:proof:addrN} of the previous
code snippet).

Thanks to this \factory{} we can now declare \coq{Z} to be an instance
of a ring using the \coq{Ring_of_Monoid.Build} \phantterm{}.
The associated \builder{}s generate, behind the scenes, instances of the
\coq{Ring_of_AbelianGroup} and \coq{AbelianGroup_of_Monoid} \mixins{}
that in turn are used to build instances of the \coq{AbelianGroup} and \coq{Ring}
structures. Indeed, when used in the context of the hierarchy version V3,
the command \hbinstance{} \coq{Z Z_Ring_axioms}
makes \coq{Z} an instance of \emph{both} structures, and not just the \coq{Ring}
one as in version V1.
Thanks to that the proof of \coq{example} can use the theory of
both structures, for example \coq{addrC} holds on Abelian groups,
\coq{addrA} holds on monoids, while \coq{addr1} holds on rings.
As a result the very same proof works on both
version V1 and V3.

Last, it is worth pointing out that the new \factory{} makes the following
two lines equivalent (the former declares
rings in V1) since they both describe the same set of \mixins{}.

\begin{coqcode}
#\hbstructure{}# Definition Ring := { R of Monoid R & Ring_of_Monoid R }.
#\hbstructure{}# Definition Ring := { R of AbelianGroup R & Ring_of_AbelianGroup R }.
\end{coqcode}

This is another example of client code that would not break: the client of the hierarchy is allowed to declare new
structures on top of existing ones.

\subsection{\HB{} in a nutshell}

By using \HB{} the hierarchy designer has the following freedoms and advantages.

\begin{itemize}
\item Operations and properties (axioms) are made available to the user
      as soon as they are used in a structure. The hierarchy designer
      is free to move them from one to another and replace an axiom
      by a lemma and vice versa.
\item Structures cannot disappear but the way they are built may change.
      The hierarchy designer is free to split structures into smaller
      ones in order to better factor and reuse parts of the hierarchy
      and the library that follows it.
\item \Mixins{} cannot disappear but can change considerably
      in their implementation. A \mixin{} can become a full fledged
      \factory{} equipped with \builder{}s to ensure backward compatibility.
\item \HB{} high level commands compile to
      the discipline of Packed Classes (Coq modules, records, coercions,
      implicit arguments, canonical structure instances, notations,
      \phantterms{}).
      This process lifts a considerable
      burden from the shoulders of the hierarchy designer and the final user
      who are no longer required to master the details of Packed Classes.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The \HB{} language}\label{sec:language}

The Coq terms handled by \HB{} are subdivided in five categories, the
\mixins{} \(\M{}\), the \factories{}~\(\F{}\), \mixinbuilders{}
\(\B{}\), the \classes{} \(\C{}\) and the \structures{}
\(\Str{}\). \Mixins{}, \factories{} and instances are tagged by the
user, through the commands \hbmixin{}, \hbfactory{} and \hbinstance{},
and the user may rely on their implementation. However structures and
classes are generated with the command \hbstructure{} and builders are
generated when using \hbinstance{} while declaring a \factory{}, and
the user may only refer to structure types, but should never rely on
their implementation, neither should they rely on explicit builders.

\subsection{\Mixins{}, \factories{} and instances}
\label{sec:hb-mixins-factories}

In this section, we call ``distinguished'' a Coq definition or record
that the developer of a library has labeled ``\mixin{}'', ``\factory{}'',
``\mixinbuilder{}'', ``\class{}'' or ``\structure{}''.

\begin{definition}[\M{}, \mixins{}]
  A \emph{\mixin{}} \(m \in \M{}\) is a distinguished Coq record with one or more
  parameters.  The first parameter must be a \coq{(T : Type)}, while
  the other parameters are \mixins{} \(\left(m_i\right)_{i \in \enum1n}\), each of which
  is applied to \coq{T} and possibly previous mixin variables. I.e.
\begin{coqcode}
Record #$m$# (T : Type) #\(\pmp{n}\)# : Type := { .. }.
\end{coqcode}
where \(\pmp{n} = (p_1 : m_1\ T) \ldots \left(p_n : m_n\ T\ p_{\sigma(n,1)}\ \ldots\ p_{\sigma(n,q_n)}\right)\)
and where for all \(i~\in~\enum1n\) we have \(q_i \in \mathbb{N}\) and the
arguments of \(m_i \in \M{}\) consist in $q_i$ of the previously quantified
mixin parameters $p_k$, i.e.~for all \(k \in \enum1{q_i}\), we
have \(\sigma(i,k) \in \enum1{i-1}\).
\end{definition}

\begin{definition}[\dep{}, \mixin{} dependencies]
  Given \(m \in \M{}\), we define \(\dep{}(m) \in \powerset\M{}\)
  as the set of all \mixins{} that occur as parameters of \(m\),
  i.e.~\(\dep{}(m) = \enum{m_1}{m_n}\).
\end{definition}

\begin{remark}For all \(i \in \enum1n\), we have
  \(\dep{}(m_i) = \enum{m_{\sigma(i,1)}}{m_{\sigma(i,q_i)}}\).
\end{remark}

\begin{definition}If \(f : \mathcal{X} \to \powerset{\mathcal{Y}}\), then
\(f^\star : \powerset{\mathcal{X}} \to \powerset{\mathcal{Y}}\) is defined as
\(f^\star(X) = \bigcup_{x \in X} f(x).\)
\end{definition}

\begin{proposition}[\dep{} is transitively closed and describes a DAG]
  \[\forall m \in \M{}, \qquad \dep{}^\star(\dep{}^\star(m)) \subseteq
  \dep{}^\star(m) \quad \textrm{and} \quad m \notin \dep{}(m).\]
\end{proposition}
\begin{proof}
  Indeed \dep{} is transitively closed because records are well typed
  in the empty context and describes a DAG since Coq does not admit
  circular definitions.
\end{proof}

\begin{definition}[\factories{} \F{}]
A \emph{\factory{}} \(f \in \F{}\) is a distinguished Coq record or definition with one or more parameters.
The first parameter must be a \coq{(T : Type)}, while the other parameters
are $n$ \mixins{}, applied to \coq{T} and previous mixin variables. I.e.
\begin{coqcode}
Record (* or Definition *) #$f$# (T : Type) #\(\pmp{n}\)# : Type := ...
\end{coqcode}
\end{definition}

\begin{definition}[$\requires{}$, factory requirements.]
  Given \(f \in \F{}\), we define \(\requires{}(f) \in \powerset\M{}\)
  as the set of all \mixins{} that occur as parameters of \(f\),
  i.e.~\(\dep{}(f) = \enum{m_1}{m_n}\).
\end{definition}

The following property holds,
\begin{proposition}[\requires{} is closed under \dep{}]
\(\forall f \in \F{}, \dep{}^\star(\requires{}(f)) \subseteq \requires{}(f).\)
\end{proposition}
\begin{proof}
Because Coq records and global definitions are well typed in the empty context.
\end{proof}

\begin{definition}[\mixinbuilders{} \B{}]
  A \emph{\mixinbuilder{}} \(\mu \in \B{}\) is a distinguished function whose
  return type is a mixin \(m_{n+1} \in \M{}\) and whose parameters are
  the carrier type \coq{(T : Type)}, \mixins{}
  \(\enum{m_1}{m_n} \in \powerset\M{}\) and a \emph{\factory{}}
  \(f \in \F{}\), such that \( \requires{}(f) =
  \enum{m_1}{m_n}\). I.e.
\begin{coqcode}
Definition #$\mu$# (T : Type) #$\pmp{n}$#: #\(f\ T\ p_1 \ldots p_n\)# -> #\(m_{n+1}\ T\ p_{\sigma(n+1,1)}\ \ldots\ p_{\sigma(n+1,q_{n+1})}\)# := ...
\end{coqcode}
\end{definition}

Note that the \mixinbuilders{} of a given \factory{} have the same set
of dependencies.

\begin{definition}[\from]
  We define \(\from{} (f, m_{n+1}) = \mu\) to be the (unique) \mixinbuilder{}
  for \(m_{n+1}\) from the \factory{} \(f\), when it exists.
\end{definition}

Note that \(\from\) is not a total function, and that \(\from{}(f, m)\) is
defined if and only if there is a declared builder that shows how to
build $m$ from $f$. In this case, we say $f$ provides $m$.

\begin{definition}[$\provides{}$]
  \( \provides{}(f) = \{m \mid \from{}(f,m) \textrm{ is defined}\}
    \in \powerset\M{}\) the set of mixins that a factory
    \(f \in \F{}\) provides, through its \mixinbuilders{}.
\end{definition}

\Mixins{} are declared by the user as the fundamental building blocks of
a hierarchy. As the next proposition shows they shall not be regarded as
different from regular \factories{}, since they are a special case.

\begin{proposition}[\( \M{} \subseteq \F{} \)] There is a way to see mixins as factories.
\end{proposition}
\begin{proof}
  For all \(m \in \M{}\) we have \(\requires{}(m) = \dep{}(m)\),
  \(\provides{}(m) = \{m\}\) and
  \(\from{}(m,m) = \left(\coq{fun T }\ \pmp{n} \ \coq{(x :}\ m\
    \coq{T }\ p_1\ \ldots p_n\coq{) => x}\right) \in \B{}.\)
\end{proof}


\begin{command} to declare a new mixin:
\begin{coqcode}
#\hbmixin{}# Record M T of #$f_1\ \ldots\ f_n$# := { .. }.
\end{coqcode}
  Declares the record \coq{axioms} inside a module \coq{M}.
  This record \coq{M.axioms} depends on the \mixins{}
  \(\requires{}(\coq{M.axioms}) = \dep{}(\coq{M.axioms}) =
  \provides{}^\star\left(\enum{f_1}{f_n}\right)\)
  and is registered both as a \mixin{} and a \factory{}. Finally It exports an
  \phantterm{} \coq{M.Build} and a notation
  \coq{M} standing for \coq{M.axioms}, so that the module name can be used to
  denote the \coq{axioms} record it contains.
\end{command}

\begin{command} to declare an instance: \hbinstance{}
  \(X\ b_1 \ldots b_k\), synthesizes terms corresponding to all the
  \mixins{} that can be built from the $b_i$. Indeed if
  \(b_i : f_i\ T\ \ldots\), then this command creates elements of types
  \(\provides{}^\star\left(\enum{f_1}{f_k}\right).\) This command also
  generates unification hints as described in
  Section~\ref{sec:target-lang}.
\end{command}

\begin{commands} to declare a new \factory{} and generate new \mixinbuilders:
\begin{coqcode}
#\hbfactory{}# Record F T of #$f_1\ \ldots\ f_n$# := { .. }.
#\hbbuilders{}# Context T (a : F T).

  Definition #$b_{n+1}$# : #$f_{n+1}$# T .. := ...
  #\hbinstance{}# T #$b_{n+1}$#.
  ..
  Definition #$b_{n+k}$# : #$f_{n+k}$# T .. := ...
  #\hbinstance{}# T #$b_{n+k}$#.
#\hbend{}#.
\end{coqcode}
  Declares the record \coq{axioms} inside a module \coq{F}.
  This record \coq{F.axioms} depends on the mixins
  \(\requires{}(\coq{F.axioms}) =
  \provides{}^\star\left(\enum{f_1}{f_n}\right)\) and is registered
  as a factory.  It exports an
  \phantterm{} \coq{F.Build} and a notation
  \coq{F} standing for \coq{F.axioms}, so that the module name can be used to
  denote the \coq{axioms} record it contains.
  Finally it uses the \factoryinstances{}
  \(b_{n+1}, \ldots, b_{n+k}\) provided by the user in order to derive
  \mixinbuilders{}, so that
  \(\provides{}(\coq{F}) = \provides{}^\star\left(\enum{f_{n+1}}{f_{n+k}}\right).\)\\
  It is thus necessary that
  \(\requires{}^\star\left(\enum{f_{n+1}}{f_{n+k}}\right) \subseteq
  \provides{}^\star\left(\enum{f_1}{f_n}\right).\)
\end{commands}

Note that the \(b_i\) are not \mixinbuilders{} since their return types
are not necessarily \mixins{}, but could be \factories{}. However, since all
\factories{} provide \mixins{} through \mixinbuilders{}, we
obtain \mixinbuilders{} out of each \(b_i\) by function composition.

\subsection{Classes and structures}
\label{sec:hb-class-struct}


\begin{definition}[\C{}, class]
A \class{} \coq{c} \(\in \C{}\) is a distinguished Coq record with one parameter
\coq{(T : Type)}. The type of each field is a \mixin{} in \M{} applied to
\coq{T} and, if needed, any number of other fields:
\begin{coqcode}
Record #$c$# (T : Type) := { #\(p_1 : m_1\ T\)#; .. ; #\(p_i : m_i\ T\ p_{\sigma(i,1)}\ \ldots p_{\sigma(i,q_i)}\)#; ..}.
\end{coqcode}
\end{definition}

\begin{definition}[\cdef{}, class definition]
  We call \(\cdef{}(c) \in \powerset\M{}\) the set of \mixins{}
  mentioned in the fields of the \class{}, i.e.~\(\{m_1, \ldots,m_n\}\).
  Given that \class{} records are well typed
  in the empty context the set of \mixin{} records is closed
  transitively.  The implementation enforces that no two \class{}
  records contains the same set of \mixins{} (disregarding the order of
  the fields), i.e.~\cdef{} is injective.
\end{definition}

\begin{invariant}[\cdef{}]
  For all \(f \in \F{}\):
  \begin{enumerate}
    \item\( \exists c \in \C{},~ \cdef{}(c) = \requires{}^\star(f)
      \cup \provides{}^\star(f),\)
    \item\( \exists C \subseteq \C{},~\cdef{}^\star(C) = \requires{}^\star(f).\)
  \end{enumerate}
\end{invariant}

Classes could also be seen as factories.
\begin{proposition}[\( \C{} \subseteq \F{} \)]
  For all \(m \in \cdef{}(c)\) we have \(\from{}(c,m_i) = p_i,\) and it
  follows that \(\requires{}(c)=\emptyset \),
  \(\provides{}(c)=\cdef{}(c).\)
\end{proposition}
However since classes are generated, their implementation may change,
thus users should not rely on constructors of classes. Hence the only
way users may refer to a class is as an argument of \hbmixin{},
\hbfactory{} or \hbstructure{}.

\begin{definition}[\Str{} Structure]
A \structure{} \coq{s} \(\in \Str{}\) is a distinguished dependent pair: a Coq record where
the value of the first field occurs in the type of the second.
The first field is \coq{(sort : Type)} and the second field is
\coq{(class : c sort)} for some \coq{c} \(\in \C{}\).
As a consequence \structures{} are in bijection with \classes{}.
\end{definition}


\begin{command} to declare a class and structure:
  \hbstructure{} \coq#Definition M := { A of# \(f_1 \ldots f_n\) \coq#}#
  crafts a class \coq{M.class_of} $\in \C{}$ where
  $\cdef{}(c) = \provides{}^\star\left(\enum{f_1}{f_n}\right) $ and the
  corresponding structure \coq{M.type} $\in \Str{}$, together with
  unification hints as described in Section~\ref{sec:target-lang}.
\end{command}


\begin{definition}[\issubclass{} \(\in \C{}\times\C{}\), \subclass{}]\label{def:subclass}
  \(c1~\issubclass{}~c2\) iff \(\cdef{}(c2) \subseteq \cdef{}(c1)\)
  \end{definition}

\subsection{Automatic inference of \mixins{}}
\label{sec:autom-infer-mixins}

Since \mixins{} may change but \factories{} stay the same, \HB{}
commands must never rely on a particular set of \mixins{} as
arguments, and \factory{} arguments must never be given explicitly by
the user. As described in Sections~\ref{sec:hb-mixins-factories}
and~\ref{sec:hb-class-struct}, \HB{} commands take a list of
\factories{} as arguments, which they expand into lists of \mixins{}
behind the scene. However \factory{} types and constructors have
\mixin{} arguments that must be inferred automatically when used. To
this end, the commands \hbmixin{} and \hbfactory{} generate
\phantterms{} for the user to replace uses of constructors of \factories{}.
These commands first create a record \(f_{\aux}\) with a
constructor \(F_{\aux}\) and then create abbreviations \(f\) and \(F\)
that automatically fill the mixin arguments of \(f_{\aux}\) and \(F_{\aux}\)
respectively.
See \cite[Section 7]{DBLP:conf/itp/MahboubiT13} for a detailed description
of how to implement these abbreviations in Coq.

\begin{coqcode}
Record #\(f_{\aux}\)# T #\(\pmp{n}\)# := #\(F_{\aux}\)# { ... }.
Notation #$f$# T := (#\(f_{\aux}\)# T ...(* $p_1 \ldots p_n$ inferred when $T$ is known *)).
Notation #$F$# T  #\(x_1\ \ldots\ x_k\)# := (#\(F_{\aux}\)# T ...(* $p_1 \ldots p_n$ inferred when $T$ is known *) #\(x_1\ \ldots\ x_k\)#).
Definition b : #$f$# T := #$F$# T #\(x_1\ \ldots\ x_n\)#.
\end{coqcode}




% As described in \cite{affeldt:hal-02463336},... % the only way to define
% % inheritance of structure in a deterministic fashion is to replace

% Cite \cite{KSdraft}

% \begin{definition}[\(\join{} \in \C{}\times\C{} \to \C{}\)]\label{def:join}
%   if \(c1, c2 \in \C{}\) then \(\join{}(c1,c2)\) is the smallest,
%   w.r.t. set inclusion, \class{} \(c\) such that
%   \(\cdef{}(c1) \cup \cdef{}(c2) \subseteq \cdef{}(c)\) if it exists.
% \end{definition}

% \begin{remark}[]
% \(\join{}(c1,c2)\) is a \subclass{} of both \(c1\) and \(c2\).
% \end{remark}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The target language: Coq with Packed, flat, Classes}
\label{sec:target-lang}

The language of Packed Classes~\cite{DBLP:conf/tphol/GarillotGMR09} is used
directly to describe the algebraic hierarchy of the Mathematical Components
library. It is based on a disciplined use of records and projections and on the
possibility of extending the elaborator of Coq via the declaration of Canonical
Structures~\cite{DBLP:conf/itp/MahboubiT13} instances. In this section, we
describe the \emph{flat} variant of Packed Classes, the target language of
\hb{}, through the hierarchy V3 extended with semirings.

The \hb{} addon can generate all the Coq declarations in this section
automatically, but some details are omitted for brevity in this section.

\subsection{Describing structures with records and projections}

We describe mathematical structures with three kinds of dependent records: mixins, classes, and structures.
As shown in Section \ref{sec:example}, a \mixin{} gathers operators and axioms newly introduced by a structure.
As in \cite[Section 2.4]{DBLP:conf/tphol/GarillotGMR09}\cite[Section 2]{KSdraft}, a class record is parametrized by the carrier type \coq{(T : Type)} and gathers all the operators and axioms of a structure by assembling mixins, and a \coq{Structure type} (a record) bundles a carrier and its class instance, as follows.
\begin{coqcode}
Module Monoid.
Record axioms (M : Type) : Type :=
  Class { Monoid_of_Type_mixin : Monoid_of_Type M; }.
Structure type : Type := Pack { sort : Type; class : axioms sort; }.
End Monoid.
\end{coqcode}
The \coq{Monoid} module plays the role of a name space and forces us to write
qualified names such as \coq{Monoid.type}; as a consequence we can reuse the
same unqualified names for other structures, i.e., class and structure record
can always be named as \coq{axioms} and \coq{type} respectively.

Mixins and classes are internal definitions to structures; in contrast,
\coq{Monoid.type} is part of the interface of the monoid structure.
As seen in section \ref{sec:example}, we declare \coq{Monoid.sort} as an
implicit coercion and lift monoid operators and axioms from projections for
the monoid \mixin{} to definitions and lemmas for \coq{Monoid.type} as follows.
\begin{coqcode}
Coercion Monoid.sort : Monoid.type >-> Sortclass.

Definition zero {M : Monoid.type} : M :=
  Monoid_of_Type.zero M (Monoid.Monoid_of_Type_mixin M (Monoid.class M)).
Definition add {M : Monoid.type} : M -> M -> M :=
  Monoid_of_Type.add M (Monoid.Monoid_of_Type_mixin M (Monoid.class M)).
Lemma addrA {M : Monoid.type} : associative (@add M).
(* Two monoid axioms `add0r` and `addr0` are omitted. *)
\end{coqcode}

Next we define Abelian groups.
Since the monoid structure is the bottom of this hierarchy its class record
\coq{Monoid} consists of just one \mixin{}. In contrast the class record
of Abelian groups consists of two \mixins{} where the second one depends
 on the former (since Abelian groups inherit from monoids).
\begin{coqcode}
Module AbelianGroup.
Record axioms (A : Type) : Type := Class {
  Monoid_of_Type_mixin : Monoid_of_Type A;
  AbelianGroup_of_Monoid_mixin : AbelianGroup_of_Monoid A Monoid_of_Type_mixin; }.
Structure type : Type := Pack { sort : Type; class : axioms sort }.
End AbelianGroup.
\end{coqcode}
In the flat variant of Packed Classes, a class record gathers mixins as its
fields directly as in above. In contrast, a class record of the non-flat variant
packs a class instance of one of the superclasses with remaining mixins, which
reduces the amount of code to implement inheritance significantly.
%Nested class records and chains of their projections exponentially slow down the
%conversion while the flat variant can mitigate the issue. 
Since we do not need
to care about the amount of code in automated generation, \hb{} uses the flat
variant of Packed Classes as its target language.

As in the monoid structure, we declare \coq{AbelianGroup.sort} as an implicit
coercion and lift additive inverse \coq{opp} and Abelian group axioms.
Since Abelian groups inherit from monoids, we also declare an implicit coercion
from Abelian groups to monoids. A coercion between structures can be defined
in two steps: first a coercion between the class record of the
superclass to the class record of the subclass (line~\ref{demo4:coe:ag:monoid:class});
and a coercion between
structure records (line~\ref{demo4:coe:ag:monoid:type}) relying on the first one.
\begin{coqcode}
Coercion AbelianGroup.sort : AbelianGroup.type >-> Sortclass.
Coercion AbelianGroup_class_to_Monoid_class (A : Type) (c : AbelianGroup A) : #\label{demo4:coe:ag:monoid:class}#
  Monoid A := Monoid.Class A (AbelianGroup.Monoid_of_Type_mixin A c).
Coercion AbelianGroup_to_Monoid (A : AbelianGroup.type) : Monoid.type := #\label{demo4:coe:ag:monoid:type}#
  Monoid.Pack (AbelianGroup.sort A) (AbelianGroup.class A).

Definition opp {A : AbelianGroup.type} : A -> A := ... .
(* Two Abelian group axioms `addrC` and `addNr` are omitted. *)
\end{coqcode}

Generally, a coercion from a structure X to another structure Y can (and should) have the following form, thanks to the corresponding coercion between classes \coq{X_class_to_Y_class}.
\begin{coqcode}
Coercion X_to_Y (T : X.type) : Y.type :=
  Y.Pack (X.sort T) ((* X_class_to_Y_class _ *) (X.class T)).
\end{coqcode}

\subsection{Multiple inheritance}

\begin{wrapfigure}[6]{r}{.4\textwidth}
 \includegraphics[width=.4\textwidth]{v4.pdf}
 \caption{V4 introduces multiple inheritance. For brevity we omit the factories/builders for the upper arrows.}
 \label{fig:puzzle_v4}
\end{wrapfigure}
In order to introduce multiple inheritance, we extend the hierarchy described in
Section~\ref{subsec:v3} with the structure of semirings %, which is another
%intermediate structure between monoids and rings
as depicted in Figure~\ref{fig:puzzle_v4}, and name it V4. Semirings introduce the
binary multiplication operator \coq{mul} and its identity element
\coq{one}.  For the sake of completeness, the full code of V4 is available in
Appendix~\ref{sec:full-v4-code}.

\begin{coqcode}
#\hbmixin{}# Record SemiRing_of_Monoid S
  of Monoid S := {
  one : S;
  mul : S -> S -> S;
  (* 7 axioms are omitted. *)
}.

#\hbfactory{}# Record Ring_of_AbelianGroup R
  of AbelianGroup R := {
  (* 2 operators and 5 axioms are omitted. *)
}.
#\hbbuilders{}# Context R (f : Ring_of_AbelianGroup R).
..
#\hbend{}#.
\end{coqcode}

Since semirings and Abelian groups do not inherit from each other,
the definition of semirings and Abelian groups are quite similar:
\begin{coqcode}
Module SemiRing.
Record axioms (S : Type) : Type := Class {
  Monoid_of_Type_mixin : Monoid_of_Type S;
  SemiRing_of_Monoid_mixin : SemiRing_of_Monoid S Monoid_of_Type_mixin;
}.
Structure type : Type := Pack { sort : Type; class : axioms sort; }.
End SemiRing.
\end{coqcode}
We define implicit coercions from the semiring structure to the carrier
and the monoid structure, and we lift semiring operators and axioms as follows:
\begin{coqcode}
Coercion SemiRing.sort : SemiRing.type >-> Sortclass.
Coercion SemiRing_to_Monoid : SemiRing.type >-> Monoid.type.

Definition one {S : SemiRing.type} : S := ... .
Definition mul {S : SemiRing.type} : S -> S -> S := ... .
(* 7 semiring axioms are omitted. *)
\end{coqcode}

The class record is defined by gathering the monoid, Abelian group, and
semiring \mixins{}. Since the rings inherit from monoids, semirings, and
Abelian groups, we define implicit coercions from the ring structure to those
three structures.
\begin{coqcode}
Module Ring.
Record axioms (R : Type) : Type := Class {
  Monoid_of_Type_mixin : Monoid_of_Type R;
  SemiRing_of_Monoid_mixin : SemiRing_of_Monoid R Monoid_of_Type_mixin;
  AbelianGroup_of_Monoid_mixin : AbelianGroup_of_Monoid R Monoid_of_Type_mixin; }.
Structure type : Type := Pack { sort : Type; class : axioms sort; }.
End Ring.

Coercion Ring.sort : Ring.type >-> Sortclass.
Coercion Ring_to_Monoid : Ring.type >-> Monoid.type.
Coercion Ring_to_SemiRing : Ring.type >-> SemiRing.type.
Coercion Ring_to_AbelianGroup : Ring.type >-> AbelianGroup.type.
\end{coqcode}

\subsection{Linking structures and instances via Canonical Structures}

We recall here how to use the Canonical
Structures~\cite{DBLP:conf/itp/MahboubiT13,Saibi99phd} mechanism, which
lets the user extend the elaborator of Coq, in order to handle
inheritance and inference of structure~\cite{affeldt:hal-02463336,KSdraft,DBLP:conf/tphol/GarillotGMR09}.
This software component
takes as input a term as written by the user and has to infer all the missing information that is necessary in order to make the term well typed.

A first example of elaboration that requires canonical structures is \(0 + 1\).
After removing all syntactic facilities, the underlying Coq term is
\coq{(add _ (zero _)) (one _)} where \coq{_} stands for an implicit piece
of information to be inferred and the constants \coq{add} and \coq{zero} come
from the monoid structure while \coq{one} comes from semirings.
When the term is type checked each \coq{_} is replaced by a unification
variable written $?_v$.
Respectively, the head and the argument of the top application
can be typed as follows:
\begin{coqcode}
  add #$?_{\texttt{M}}$# (zero #$?_{\texttt{M}}$#) : Monoid.sort #$?_{\texttt{M}}$# -> Monoid.sort #$?_{\texttt{M}}$#
  one #$?_{\texttt{SR}}$# : SemiRing.sort #$?_{\texttt{SR}}$#
\end{coqcode}
where \(?_{\texttt{M}}~\coq{: Monoid.type}\) and
\(?_{\texttt{SR}}~\coq{: SemiRing.type}\).
In order to type check the application Coq has to unify \(\coq{Monoid.sort}~?_{\texttt{M}}\) with
\(\coq{SemiRing.sort}~?_{\texttt{SR}}\), which is not trivial: it amounts at
finding a structure that is both a monoid and a semiring, possibly the
smallest one~\cite[Sect.~4]{KSdraft}.
This piece of information can be inferred from the hierarchy and its inheritance
relation (Definition~\ref{def:subclass}) and we can tell Coq to exploit it by
declaring \coq{SemiRing_to_Monoid : SemiRing.type -> Monoid.type} as
canonical. With that hint Coq will pick \(?_{\texttt{M}}\) to be
\(\coq{SemiRing_to_Monoid}~?_{\texttt{SR}}\) as the canonical solution for this
unification problem.
In general, all the coercions between structures must be declared
as canonical. % to make this inference work.

Another example of elaboration problem is \(- 1\), which hides the term~\coq{opp _ (one _)}.
Here \coq{opp} and \coq{one} are respectively from Abelian groups and semirings,
which do not inherit each other but whose smallest common substructure is
rings; thus we have to extend the unifier to solve a unification problem
\(\coq{AbelianGroup.sort}~?_{\texttt{AbG}}~\coq{= SemiRing.sort}~?_{\texttt{SR}}\) by instantiating \(?_{\texttt{AbG}}\) and \(?_{\texttt{SR}}\) with \(\coq{Ring_to_AbelianGroup}~?_{\texttt{R}}\) and \(\coq{Ring_to_SemiRing}~?_{\texttt{R}}\) respectively where \(?_{\texttt{R}}\) is a fresh unification variable of type \coq{Ring.type}.
This hint can be given as follows:% can be done by the following canonical declaration.
\begin{coqcode}
Canonical AbelianGroup_to_SemiRing (S : Ring.type) :=
  SemiRing.Pack (AbelianGroup.sort (Ring_to_AbelianGroup S)) (Ring.class S)).
\end{coqcode}

Similarly, one can apply an algebraic theory to an instance (an example) of that structure, e.g., \(2 \times 3\) where \(2\) and \(3\) have type \(\mathbb{Z}\).
The same mechanism of canonical structures let us extend the unifier to solve \(\coq{SemiRing.type}~? = \mathbb{Z}\).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The implementation of \HB{} in Coq-Elpi}\label{sec:implementation}

The implementation is based on the Elpi
extension language for Coq. In this section we introduce the features of the
programming language that came in handy in the development of \HB{} and
comment a few code snippets.

Coq-Elpi~\cite{CoqElpi} is a Coq plugin embedding
Elpi and providing an
extensive, high level, API to access and script the Coq system at the
vernacular level.
This API lives in the \elpi{coq} namespace and lets one easily declare
records, coercions, canonical structures, modules, implicit arguments, etc.
The most basic Coq data type exposed to Elpi is the one of references to global
declarations:

\begin{elpicode}
kind gref  type.                 % The data type of references to global terms
type indt  inductive -> gref.    % eg: Coq.Init.Datatypes.nat
type indc  constructor -> gref.  % eg: Coq.Init.Datatypes.O
type const constant -> gref.     % eg: Coq.Init.Peano.plus
\end{elpicode}

The arguments of the three constructors are opaque to Elpi, that can only use
values of these types via dedicated APIs. For example the API for declaring
an inductive type will generate a value of type \elpi{inductive} that
is printed as, for example, \elpi{«nat»}.

Elpi~\cite{DBLP:conf/lpar/DunchevGCT15} is a dialect
of $\lambda$Prolog~\cite{Miller:2012:PHL:2331097}, an higher order
logic programming language that makes it easy to manipulate abstract syntax
tree with binders. Coq-Elpi takes full advantage of this capability by
representing Coq terms in Higher Order Abstract
Syntax~\cite{10.1145/53990.54010} style, reusing the binder of the programming
language in order to represent Coq's ones. Here is an excerpt of the data
type of Coq terms:

\begin{elpicode}
kind term type.                              % The data type of Coq terms
type global gref -> term.                    % eg: nat, O, S, plus, ...
type fun    term -> (term -> term) -> term.  % eg: fun x : t => b(x)
type app    list term -> term.               % eg: app [hd|args]
... % all other term constructors are omitted for brevity
\end{elpicode}

Note that the \elpi{fun} constructor holds a $\lambda$Prolog function.
In this syntax the Coq term \coq{(fun x : nat => x x)} becomes
\elpi{(fun (global (indt «nat»)) x\ app[x, x])} where \elpi{x\} binds \elpi{x}
in the body of the function. Substitution of a bound variable for a term
can be computed by applying a term (of function type) to an argument.

Data types with binders are also used as input to high level APIs that build
terms behind the scenes. For example a Coq record is just an inductive type
and the API to declare one must allow the type of a field to depend on the
fields that comes before it. Note that the \elpi{field} constructor
takes a coercion flag, the name of the field, its type and binds a term
in the remaining record declaration.

\begin{elpicode}
kind indt-decl type.              % The type of an inductive type declaration
type record      string -> term -> string -> record-decl -> indt-decl.
type field       bool -> string -> term -> (term -> record-decl) -> record-decl.
type end-record  record-decl.
... % constructors for non-record inductive types are omitted for brevity

external pred coq.env.add-indt i:indt-decl, o:inductive.
external pred coq.CS.canonical-projections i:inductive, o:list (option constant).
\end{elpicode}

The \elpi{pred} keyword documents types and modes (input or output) of the
arguments of a predicate, while \elpi{external} signals that the
predicate is a builtin (in other words it is implemented in
OCaml rather than $\lambda$Prolog).

We comment these two builtin predicates and the \elpi{indt-decl} type
while looking at the code of \elpi{declare-structure} that is in charge
of scripting the following Coq code:% (given as a parameter \coq{axioms}):

\begin{coqcode}
Structure type : Type := Pack { sort : Type; class : axioms sort }.
\end{coqcode}

The following Elpi code builds the declaration, type checks it, adds it to the
Coq environment and finally returns the projections for the sort and the class
fields.% (it is handy to have them in the rest of the code).

\begin{elpicode}
pred declare-structure i:gref, o:term, o:term, o:term.

declare-structure ClassName Structure SortProjection ClassProjection :- std.do! [
  StructureDeclaration =
    record "type" {{ Type }} "Pack" (
      field tt "sort" {{ Type }} s\                        %\label{binder:sort}%
      field ff "class" (app [global ClassName, s]) _\
    end-record),
  coq.typecheck-indt-decl StructureDeclaration,
  coq.env.add-indt StructureDeclaration StructureName,     %\label{record:decl}%
  coq.CS.canonical-projections StructureName [some SortP, some ClassP],
  Structure = global (indt StructureName),
  SortProjection = global (const SortP),
  ClassProjection = global (const ClassP),
].
\end{elpicode}

Note that the binder \elpi{s\} at line \ref{binder:sort} lets one mention
the first field in the type of the second.
The syntax \elpi{{{ Type }}} is a quotation: it lets
one use the syntax of Coq to write an Elpi expression of type \elpi{term}.
The API \elpi{coq.CS.canonical-projections} lets us find the projections
automatically generated by Coq for a given record.
The last detail worth mentioning is that this program makes no use of
backtracking: the \elpi{std.do!} combinator signals that.

In the simple case of the structure record, the number of fields, and hence
the number of binders, is fixed. On the contrary the class record has one
field per \mixin{} and each of them can depend on the previous ones.
In order to synthesize terms with binders in an inductive fashion (using
a recursive predicate) $\lambda$Prolog lets one postulate fresh nominal
constants using the \elpi{pi} operator and attach to the
nominal some knowledge in the form of a clause via the \elpi{=>} operator.
This process is called binder mobility: the binder is moved from
the data (that we are building) to the program (the context of the
current computation).
This feature is key to the following code that synthesizes the
declaration of the fields of the class record.

\begin{elpicode}
pred synthesize-fields.field-for-mixin i:mixinname, o:term.
pred synthesize-fields i:list mixinname, i:term, o:record-decl.

synthesize-fields [] _ Decl :- Decl = end-record.
synthesize-fields [M|ML] T Decl :- std.do! [
  get-mixin-modname M ModName, Name is ModName ^ "_mixin",                          %\label{craft:name}%
  dep1 M Deps,                                         %\label{deps:fetch}%
  std.map Deps synthesize-fields.field-for-mixin Args, %\label{deps:satisfy}%
  Type = app[ global M, T | Args ],                    %\label{build:type}%
  Decl = (field ff Name Type f\ Fields f),
  pi m\                                                %\label{postulate:m}%
    synthesize-fields.field-for-mixin M m =>           %\label{postulate:satisfy}%
    synthesize-fields ML T (Fields m)                  %\label{rec:call}%
].
\end{elpicode}

The first predicate \elpi{synthesize-fields.field-for-mixin} is used
to link a \mixin{} to a nominal that corresponds to the record field
for that mixin. It has no clauses in the base program but some clauses
are added dynamically by \elpi{synthesize-fields}.

The second predicate proceeds by recursion on the (topologically sorted) list of \mixins{},
and terminates when the list is empty. If the list contains a \mixin{} \elpi{M}
then it crafts a \elpi{Name} for it (line~\ref{craft:name}),
fetches its dependencies (line~\ref{deps:fetch}) and
finds the (previously declared) record fields holding these \mixins{}
(line~\ref{deps:satisfy}).
The \elpi{(std.map L1 P L2)} predicate relates the two lists \elpi{L1} and
\elpi{L2} point wise using the predicate \elpi{P}.

Line~\ref{build:type} builds the type of the field: the \mixin{} name applied
to the type (sort) and all its dependencies.
Note that the \elpi{Fields} variable, representing the declaration of the
next fields, is under the binder for \elpi{f} (the current field).
In order to make the recursive call under that binder (line~\ref{rec:call})
and recursively process \elpi{ML} we postulate a nominal
\elpi{m} (line~\ref{postulate:m}) that is a term satisfying any
future dependency on the current \mixin{} (line~\ref{postulate:satisfy})
and we replace \elpi{f} by \elpi{m} in \elpi{Fields} by writing
\elpi{(Fields m)}.


% The code of \elpi{synthesize-fields} makes an idiomatic use
% of \elpi{=>} in $\lambda$Prolog: the current program is temporarily
% extended with a clause.
%
% \marginpar{this may go}The same operation, but with a persistent
% effect, is made available by Coq-Elpi via a dedicated API to extend
% data bases. A data base is a named set of clauses and
% commands are typically built by accumulating specific clauses on top
% of a data base. Here an excerpt of the \verb+hierarchy.db+ data base and
% of the \elpi{declare_mixin} command. Text between \verb+lp:{{+ and \verb+}}+
% is Elpi code embedded in a Coq file. All the vernacular commands beginning
% with \coq{Elpi} are provided by the Coq-Elpi plugin.
%
% \begin{coqcode}
% Elpi Db hierarchy.db lp:{{
%   pred dep1 o:mixinname, o:list mixinname.
%   ... % for brevity we omit class and join
% }}.
% Elpi Command declare_mixin.
% Elpi Accumulate Db hierarchy.db.
% Elpi Accumulate lp:{{
%   main [str S] :- !, std.do! [
%     coq.locate S M,
%     coq.env.typeof M Ty,
%     gather-mixin-dendencies Ty [] ML, % implementation omitted for brevity
%     coq.elpi.accumulate "hierarchy.db" (clause _ _ (dep1 M ML)),
%     ...
%   ].
%   main _ :- coq.error "Usage: declare_mixin <mixin>".
% }}.
% \end{coqcode}
%
% Line 11 computes the dependencies of \mixin{} \elpi{M} given
% its type and line 12 crafs a clause for \elpi{dep1} and
% adds it to the data base \elpi{"hierarchy.db"}.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Benchmark}
%if we can port ssralg, or not... It would be nice, but maybe its a bit late.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related work}
The most closely related work is the one about Packed Classes~\cite{DBLP:conf/tphol/GarillotGMR09} on which we
build. The main differences are that \HB{} is a higher level language
that is compiled down to (flat) Packed Classes. The systematic use of
\factories{} makes the user interface of a hierarchy stable under the insertion of
structures, a property that Packed Classes lacks.
Finally many of the intricacies of Packed Classes are hidden to the user by
the compilation step, in particular creating all the necessary coercions and canonical structure declarations,
especially in the case of diamonds or when merging several libraries, which used to cause the need for \textit{a posteriori}
validation of a hierarchy design~\cite{KSdraft}. It also opens the way
to automatically detect and solve problems tied to non judgmental commutative diagrams when forgetting
structure~\cite{affeldt:hal-02463336}.


In~\cite{CaretteCombinators} Carette and O'Connor describe the language of
Theory Presentation Combinators that can be used to describe a hierarchy of
algebraic structures.
They focus on the categorical semantics of the language that is built upon
the category of context.
They do not describe any actual compilation to the language of a mainstream
interactive prover, indeed they claim their language to be mostly type theory
independent. We know they considered targeting type theory and the language
of unification hints~\cite{10.1007/978-3-642-03359-9_8}
(a superset of the one of Canonical Structures),
but we could not find any written trace of that. Language-wise they provide
keywords such as \verb+combine+ and \verb+over+ to share (reuse) a property
when defining a new structure. For example in order to avoid restating
the commutativity property when defining Abelian groups they combine
a commutative monoid and a group forcing the subjacent monoid to coincide: %
\verb-CommutativeGroup := combine CommutativeMonoid , Group over Monoid.-
In our language \HB{} the same role is played by \emph{\mixins{}}.
A \mixin{} lets one write once and for all a property and abstract it over types
and operations so that it can be reused in all the structures that need it.
One operation \HB{} allows for but that does not seem to be possible in the
setting of Presentation Combinators is the one of replacing an axiom with a
lemma and vice versa. As shown in \autoref{subsec:evolution} \HB{} supports
that.

The MMT system~\cite{RABE20131} provides a framework to describe formal
languages in a logical framework, providing good support for binders and
notations. It also provides an expressive module system to organize
theories and express relations among them in the form of functors.
At the time of writing
it provides limited support for elaborating user input taking systematic
advantage of the contents of the theories. The elaborator can be extended
by the user writing Scala code, and in principle use the contents of the
libraries to make sense of an incomplete expressions, but no higher level
language or mechanism is provided.

The library of the Mizar system features a hierarchy of algebraic
structures~\cite{7733265}. In spite of lacking dependent types, Mizar
provides the concept of attributed types and adjectives
that can be used to describe the signature of structures as one would
do with a dependently typed record and their properties as
one would define a conjunctive predicate.
The Mizar language also provides the notion of cluster that is used
to link structures: by showing that property $P$ implies property $Q$
one can inform automation that structures characterized by $P$ are
instances of structures characterized by $Q$. The foundational theory of Mizar
features an extensional notion of equality that makes it easy
to share the signature or the properties of structures by just requiring
a proof of their equivalence that is in turn used by automation to treat
equivalent structures as equal.

The concepts of \factory{} and \builder{} presented here is akin to the
\verb-AbstractFactory- and \verb-Builder- pattern from "the Gang Of Four" design
patterns~\cite{gamma1995design} in the sense that \factories{} are used
to build an arbitrary number of objects (here \mixin{} instances).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}
In this paper we design and implement \HB{}, a high level language to describe
hierarchies of algebraic structures. The implementation of \HB{} is
based on the Elpi extension language for the Coq system and is available
at \url{https://github.com/math-comp/hierarchy-builder}.
The implementation amounts to approximately a thousand lines of (commented)
Elpi code and tree hundred lines of Coq vernacular. It took less than one month
to implement \HB{}, but its design took several years of attempts and fruitful
discussions with the people we thank below.

The \HB{} language is only loosely tied to Coq or even Type Theory.
We believe it could be adopted with no major change to other tools. Indeed the
properties and invariants that link \factories{}, \mixins{} and \classes{}
are key to rule out meaningless or ambiguous sentences and are not
specific to our logic setting. Moreover
most logics feature packing construction similar to records.

The compilation scheme we present in \autoref{sec:target-lang} is tied to dependent records,
that are available in Coq but also
in other provers based on Type Theory such a Matita~\cite{DBLP:conf/cade/AspertiRCT11}
and Lean~\cite{DBLP:conf/cade/MouraKADR15}.
We chose the flat variant of Packed Classes as the target for \HB{} because the
Mathematical Components library uses Packed Classes as well: As of today
Packed Classes offer the best compromise between flexibility and
performance~\cite[Section 8]{DBLP:conf/itp/MahboubiT13} in Coq.
Of course one could imagine a future were other approaches such as
telescopes~\cite{telescopes} or unbundled
classes~\cite{mathclasses} would offer equal or better performances in Coq, or in
another system.
It is a virtue of our work to provide a user language that is separate
from the implementation one. We believe it would take a minor coding effort to
retarget \HB{} to another bundling approach.

We leave to future work extending \HB{} to support structures parametrized
by structures such as the one of module over a ring.
We also leave to future
work the automatic synthesis of the notion of morphism between structures
of the hierarchy.

\section*{Acknowledgments}

We are particularly grateful to Georges Gonthier, Assia Mahboubi and
Florent Hivert for the many discussions we had that were instrumental
in coining the concepts formalized here. We thank as well other
developers of the Mathematical Components library and members of
Dagstuhl seminar 18341, for the helpful discussions we had. We also
thank many Coq developers and users who showed interest and support in
this work. Finally, we thank the anonymous reviewers of this paper for
their useful comments.

\bibliography{biblio}
\newpage
\appendix

\section{Coq reference}
\label{sec:coq-reference}
\begin{coqcode}
Section OperationProperties.

Variables (T : Type) (e : T) (inv : T -> T) (op : T -> T -> T) (add : T -> T -> T).

Definition left_id  := forall x, op e x = x.
Definition right_id := forall x, op x e = x.

Definition left_inverse := forall x, op (inv x) x = e.
Definition right_inverse := forall x, op x (inv x) = e.

Definition commutative := forall x y, op x y = op y x.
Definition associative := forall x y z, op x (op y z) = op (op x y) z.

Definition left_distributive  := forall x y z, op (add x y) z = add (op x z) (op y z).
Definition right_distributive := forall x y z, op x (add y z) = add (op x y) (op x z).

End OperationProperties.
\end{coqcode}

\section{Proof of addrC}
\label{sec:proof-addrc}
\begin{coqcode}
Lemma addrC {R : Ring.type} : commutative (@add R).
Proof.
have innerC (a b : R) : a + b + (a + b) = a + a + (b + b).
  by rewrite -[a+b]mul1r -mulrDl mulrDr !mulrDl !mul1r.
have addKl (a b c : R) : a + b = a + c -> b = c.
  apply: can_inj (add a) (add (opp a)) _ _ _.
  by move=> x; rewrite addrA addNr add0r.
have addKr (a b c : R) : b + a = c + a -> b = c.
  apply: can_inj (add ^~ a) (add ^~ (opp a)) _ _ _.
  by move=> x; rewrite /= -addrA addrN addr0.
move=> x y; apply: addKl (x) _ _ _; apply: addKr (y) _ _ _.
by rewrite -!addrA [in RHS]addrA innerC !addrA.
Qed.
\end{coqcode}

\section{Full V4 code}
\label{sec:full-v4-code}
\begin{coqcode}
From Coq Require Import ssreflect ssrfun ZArith.
From HB Require Import structures.

Declare Scope hb_scope.
Delimit Scope hb_scope with G.
Open Scope hb_scope.

(* Bottom mixin in Fig. 2. *)
HB.mixin Record Monoid_of_Type M := {
  zero : M;
  add : M -> M -> M;
  addrA : associative add;
  add0r : left_id zero add;
  addr0 : right_id zero add;
}.
HB.structure Definition Monoid := { M of Monoid_of_Type M }.
Notation "0" := zero : hb_scope.
Infix "+" := (@add _) : hb_scope.

(* Bottom right mixin in Fig. 2. *)
HB.mixin Record AbelianGroup_of_Monoid A of Monoid A := {
  opp : A -> A;
  addrC : commutative (add : A -> A -> A);
  addNr : left_inverse zero opp add;
}.
HB.structure Definition AbelianGroup := { A of Monoid A & AbelianGroup_of_Monoid A }.
Notation "- x" := (@opp _ x) : hb_scope.
Notation "x - y" := (x + - y) : hb_scope.

(* Bottom left mixin in Fig. 2. *)
HB.mixin Record SemiRing_of_Monoid S of Monoid S := {
  one : S;
  mul : S -> S -> S;
  mulrA : associative mul;
  mul1r : left_id one mul;
  mulr1 : right_id one mul;
  mulrDl : left_distributive mul add;
  mulrDr : right_distributive mul add;
  mul0r : left_zero zero mul;
  mulr0 : right_zero zero mul;
}.
HB.structure Definition SemiRing := { S of Monoid S & SemiRing_of_Monoid S }.
Notation "1" := one : hb_scope.
Infix "*" := (@mul _) : hb_scope.

Lemma addrN {A : AbelianGroup.type} : right_inverse (zero : A) opp add.
Proof. by move=> x; rewrite addrC addNr. Qed.

(* Top right factory in Fig. 2. *)
HB.factory Record Ring_of_AbelianGroup R of AbelianGroup R := {
  one : R;
  mul : R -> R -> R;
  mulrA : associative mul;
  mul1r : left_id one mul;
  mulr1 : right_id one mul;
  mulrDl : left_distributive mul add;
  mulrDr : right_distributive mul add;
}.

(* Builder arrow from top right to bottom left in Fig. 2. *)
HB.builders Context (A : Type) (f : Ring_of_AbelianGroup A).

  Fact mul0r : left_zero zero mul.
  Proof.
  move=> x; rewrite -[LHS]add0r addrC.
  rewrite -{2}(addNr (mul x x)) (addrC (opp _)) addrA.
  by rewrite -mulrDl add0r addrC addNr.
  Qed.

  Fact mulr0 : right_zero zero mul.
  Proof.
  move=> x; rewrite -[LHS]add0r addrC.
  rewrite -{2}(addNr (mul x x)) (addrC (opp _)) addrA.
  by rewrite -mulrDr add0r addrC addNr.
  Qed.

  Definition to_SemiRing_of_Monoid := SemiRing_of_Monoid.Build A _ mul mulrA
     mul1r mulr1 mulrDl mulrDr mul0r mulr0.
  HB.instance A to_SemiRing_of_Monoid.

HB.end.
HB.structure Definition Ring := { A of AbelianGroup A & Ring_of_AbelianGroup A }.

(* Top left factory in Fig. 2. *)
(* It is an exact copy of the bottom right mixin. *)
HB.factory Definition Ring_of_SemiRing R of SemiRing R := AbelianGroup_of_Monoid R.
(* The corresponding builder is the identity. *)
HB.builders Context (R : Type) (f : Ring_of_SemiRing R).
  Definition to_AbelianGroup_of_Monoid : AbelianGroup_of_Monoid R := f.
  HB.instance R to_AbelianGroup_of_Monoid.
HB.end.

(* Right-most factory in Fig. 2. *)
HB.factory Record Ring_of_Monoid R of Monoid R := {
  one : R;
  opp : R -> R;
  mul : R -> R -> R;
  addNr : left_inverse zero opp add;
  addrN : right_inverse zero opp add;
  mulrA : associative mul;
  mul1r : left_id one mul;
  mulr1 : right_id one mul;
  mulrDl : left_distributive mul add;
  mulrDr : right_distributive mul add;
}.

HB.builders Context (R : Type) (f : Ring_of_Monoid R).

  Lemma addrC : commutative (add : R -> R -> R).
  Proof. (* Exactly the same as in Appendix B. *)
  have innerC (a b : R) : a + b + (a + b) = a + a + (b + b).
    by rewrite -[a+b]mul1r -mulrDl mulrDr !mulrDl !mul1r.
  have addKl (a b c : R) : a + b = a + c -> b = c.
    apply: can_inj (add a) (add (opp a)) _ _ _.
    by move=> x; rewrite addrA addNr add0r.
  have addKr (a b c : R) : b + a = c + a -> b = c.
    apply: can_inj (add ^~ a) (add ^~ (opp a)) _ _ _.
    by move=> x; rewrite /= -addrA addrN addr0.
  move=> x y; apply: addKl (x) _ _ _; apply: addKr (y) _ _ _.
  by rewrite -!addrA [in RHS]addrA innerC !addrA.
  Qed.

  (* Builder to the bottom right mixin. *)
  Definition to_AbelianGroup_of_Monoid :=
    AbelianGroup_of_Monoid.Build R opp addrC addNr.
  HB.instance R to_AbelianGroup_of_Monoid.

  (* Builder to the top right factory, which is compiled to the bottom left mixin. *)
  Definition to_Ring_of_AbelianGroup := Ring_of_AbelianGroup.Build R one mul
    mulrA mul1r mulr1 mulrDl mulrDr.
  HB.instance R to_Ring_of_AbelianGroup.

HB.end.
\end{coqcode}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "hb.tex"
%%% TeX-command-extra-options: "-shell-escape"
%%% ispell-local-dictionary: "english"
%%% End:
